<article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Unreal Engine Persistent Data Compendium">
    <meta itemprop="description" content="Compendium for traveling, disconnecting, and persisting data across such scenarios">
    <meta itemprop="datePublished" content="2022-09-01T00:00:00+00:00">
    <meta itemprop="dateModified" content="2023-04-23T00:00:00+00:00">

    <div class="page__inner-wrap">
      

      <section class="page__content e-content" itemprop="text">
        <p>I suppose you already have at least two levels in your game, where players are traveling from one level to the other. After players make it to the new level, they find out that the data they used to have in the old level is simply gone. In other scenarios, due to some harsh net conditions, players may be disconnected from the server and be reconnected back, which if not handled properly will result in a data loss too!</p>

<h2 id="introduction" class="">Introduction<a class="header-link" href="#introduction" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>In this post, we’ll touch on <strong>travel</strong> and <strong>disconnect</strong> (which is in fact an uninitiated travel) scenarios in Unreal Engine. More importantly, we’ll be discovering several ways to make our data persist over such scenarios. Furthermore, we’ll get to know how those ways differ from one another, and in what scenarios we should pick one over the other.</p>

<h2 id="travel-seamless-vs-hard" class="">Travel: Seamless vs. Hard<a class="header-link" href="#travel-seamless-vs-hard" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>In Unreal, there are two main ways to travel: <strong>Seamless</strong> and <strong>non-seamless</strong> which is also referred to as <strong>hard</strong> travel. The main difference, is that <strong>seamless</strong> travel is a non-blocking operation due to asynchronous level loading, while <strong>non-seamless</strong> will be a blocking call due to synchronous level loading. In addition, in <strong>non-seamless</strong> traveling, players are disconnected from the server and reconnect when the new map loads synchronously, while in <strong>seamless</strong> traveling, players stay connected but are transferred to an asynchronously loaded <a href="https://wizardcell.com/unreal/persistent-data/#enabling-seamless-travel-and-transition-map">transition map</a>, until the destination level has asynchronously loaded too.</p>

<p><strong>Seamless</strong> travel should be favored over a <strong>non-seamless</strong> one when possible, as it results in a smoother experience generally, and avoids some other issues when the client reconnects.</p>

<p>There are three ways in which a <strong>non-seamless</strong> travel must occur:</p>

<ul>
  <li>When loading a map for the first time</li>
  <li>When connecting to a server for the first time as a client (e.g. joining sessions)</li>
  <li>When you want to end a multiplayer game, and start a new one</li>
</ul>

<p class="notice--warning"><strong>Note:</strong> The first way doesn’t mean loading every new map for the first time, but the first map the initial connection loads. Otherwise, that would mean, any new map we travel to, would end up to be a <strong>non-seamless</strong> travel, which is incorrect.</p>

<h3 id="travel-types" class="">Travel Types<a class="header-link" href="#travel-types" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Now that we understand the ways of travel in Unreal, let’s understand the travel types, which can be seen in this enum class:</p>

<figure>
      <figcaption>
        <p class="figure-title">EngineBaseTypes.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="c1">// Traveling from server to server.</span>
<span class="n">UENUM</span><span class="p">()</span>
<span class="k">enum</span> <span class="n">ETravelType</span>
<span class="p">{</span>
    <span class="cm">/**Absolute URL. */</span>
    <span class="n">TRAVEL_Absolute</span><span class="p">,</span>
    <span class="cm">/** Partial (carry name, reset server).*/</span>
    <span class="n">TRAVEL_Partial</span><span class="p">,</span>
    <span class="cm">/** Relative URL. */</span>
    <span class="n">TRAVEL_Relative</span><span class="p">,</span>
    <span class="n">TRAVEL_MAX</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<p>Let’s explain each travel type and its intended use:</p>

<ul>
  <li>
<strong>TRAVEL_Relative</strong> (same server, and last <a href="https://wizardcell.com/unreal/persistent-data/#7-game-options-string">options string</a> is kept): Current <a href="https://wizardcell.com/unreal/persistent-data/#url-structure">URL</a> is relative to last URL , so we aren’t disconnected from the server, making it ideal for <strong>seamless</strong> travel. Therefore, this travel type is a requirement when <strong>seamless</strong> traveling on client. The last options string is carried over to the new level.</li>
  <li>
<strong>TRAVEL_Partial</strong> (server resets, though last options string is kept): Current URL is partial to last URL, so we are disconnected from the server, which corresponds to a <strong>non-seamless</strong> travel. The last options string is carried over to the new map.</li>
  <li>
<strong>TRAVEL_Absolute</strong> (server resets, and last options string is ignored): Current URL is absolute, meaning that last URL (including last options string) is flushed, so we are disconnected from the server, which corresponds to a <strong>non-seamless</strong> travel.</li>
</ul>

<p>Here is a summary table, showing for each travel type what’s kept (last server URL, and last options string), and if compatible with <strong>seamless</strong> and <strong>hard</strong> travels:</p>

<table class="table">
  <thead>
    <tr>
      <th>Travel Type</th>
      <th style="text-align: center">Keeps Last Server URL?</th>
      <th style="text-align: center">Keeps Last Options String?</th>
      <th style="text-align: center">Supported by Seamless Travel?</th>
      <th style="text-align: center">Supported by Hard Travel?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Relative</strong></td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
    </tr>
    <tr>
      <td><strong>Partial</strong></td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
    </tr>
    <tr>
      <td><strong>Absolute</strong></td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
    </tr>
  </tbody>
</table>

<h3 id="native-travel-drivers">Native Travel Drivers<a class="header-link" href="#native-travel-drivers" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>There are three main native functions that drive traveling: <code class="language-plaintext highlighter-rouge">UEngine::Browse()</code>, <code class="language-plaintext highlighter-rouge">UWorld::ServerTravel()</code>, and <code class="language-plaintext highlighter-rouge">APlayerController::ClientTravel()</code>. These can be a bit confusing when trying to figure out which one to use, so here are some guidelines that should help:</p>

<h4 id="uenginebrowse" class="">UEngine::Browse<a class="header-link" href="#uenginebrowse" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>Is like a hard reset when loading a new map.</li>
  <li>Will always result in a non-seamless travel.</li>
  <li>Will result in the server disconnecting current clients before travelling to the destination map.</li>
  <li>Clients will disconnect from current server.</li>
  <li>Dedicated server cannot travel to other servers, so the map must be local (cannot be URL).</li>
</ul>

<h4 id="uworldservertravel" class="">UWorld::ServerTravel<a class="header-link" href="#uworldservertravel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>For the server only.</li>
  <li>Will jump the server to a new world/level.</li>
  <li>All connected clients will follow.</li>
  <li>This is the way multiplayer games travel from map to map, and the server is the one in charge to call this function.</li>
  <li>The server will call <code class="language-plaintext highlighter-rouge">APlayerController::ClientTravel()</code> for all client players that are connected.</li>
</ul>

<h4 id="aplayercontrollerclienttravel">APlayerController::ClientTravel<a class="header-link" href="#aplayercontrollerclienttravel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>If called from a client, will travel to a new server.</li>
  <li>If called from a server, will instruct the particular client to travel to the new map (but stay connected to the current server).</li>
</ul>

<h3 id="blueprint-travel-drivers">Blueprint Travel Drivers<a class="header-link" href="#blueprint-travel-drivers" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>In <strong>Blueprints</strong>, the two functions/nodes that drive traveling are:</p>

<h4 id="openlevel" class="">OpenLevel<a class="header-link" href="#openlevel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>This function will always result in a <strong>hard</strong> travel (even if <strong>seamless</strong> travel is <a href="https://wizardcell.com/unreal/persistent-data/#enabling-seamless-travel-and-transition-map">enabled</a>.<br>
If called from client, will travel to a new server, without disconnecting other clients from the server. If called from a listen-server, will travel the listen-server player to a new map, disconnecting clients back to the entry/default map. If called from a dedicated-server, will result in a travel failure, disconnecting clients back to the default map, unless the travel URL has option “listen”, which will instruct the particular client to travel to the new map as a listen-server, however, other clients will disconnect back to the default map.<br>
It corresponds to the native function <code class="language-plaintext highlighter-rouge">UGameplayStatics::OpenLevel()</code>, which calls <code class="language-plaintext highlighter-rouge">UEngine::SetClientTravel()</code>. On the next tick, <code class="language-plaintext highlighter-rouge">UGameEngine::Tick()</code> calls <code class="language-plaintext highlighter-rouge">UEngine::Browse()</code>, which calls <code class="language-plaintext highlighter-rouge">UEngine::LoadMap()</code>. By default <code class="language-plaintext highlighter-rouge">bAbsolute = true</code>, making it an <strong>Absolute</strong> travel, otherwise, it’s <strong>Relative</strong>.</li>
</ul>

<p class="notice--danger"><strong>Caution:</strong> Testing traveling (and many more networking functionalities) in PIE should be avoided, as that can crash your editor, and won’t reflect how your code is going to function in realtime. Stick to traveling in a standalone/packaged game!</p>

<h4 id="executeconsolecommand" class="">ExecuteConsoleCommand<a class="header-link" href="#executeconsolecommand" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>This function and <code class="language-plaintext highlighter-rouge">Command</code> parameter be <code class="language-plaintext highlighter-rouge">ServerTravel &lt;MapName&gt;</code> or <code class="language-plaintext highlighter-rouge">Travel &lt;MapName&gt;</code>(the former is the one usually used as it can be <strong>seamless</strong> while the latter can’t) where they travel to the specified map, passing along previously set options string, as they are <strong>Relative</strong> and <strong>Partial</strong> travels respectively. They correspond to the native functions: <code class="language-plaintext highlighter-rouge">UEngine::HandleServerTravelCommand()</code> and <code class="language-plaintext highlighter-rouge">UEngine::HandleTravelCommand()</code> respectively. Another command that you can use is <code class="language-plaintext highlighter-rouge">Open &lt;MapName&gt;</code> which opens the specified map, without passing previously set options string, as it’s an <strong>Absolute</strong> travel. It corresponds to the native function <code class="language-plaintext highlighter-rouge">UEngine::HandleOpenCommand()</code>, which calls <code class="language-plaintext highlighter-rouge">UEngine::SetClientTravel()</code>. On the next tick, <code class="language-plaintext highlighter-rouge">UGameEngine::Tick()</code> calls <code class="language-plaintext highlighter-rouge">UEngine::Browse()</code>, which calls <code class="language-plaintext highlighter-rouge">UEngine::LoadMap()</code>. It’s always an <strong>Absolute</strong> travel.</li>
</ul>

<p>Luckily those commands are autocompleted when typed inside the <strong>Console Command</strong> at runtime:</p>

<figure>
      <figcaption>
        <p class="figure-title">BaseInput.ini</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="err">+</span><span class="py">ManualAutoCompleteList</span><span class="p">=</span><span class="s">(Command="Open",Desc="&lt;MapName&gt; Opens the specified map, doesn't pass previously set options")</span>
<span class="err">+</span><span class="py">ManualAutoCompleteList</span><span class="p">=</span><span class="s">(Command="Travel",Desc="&lt;MapName&gt; Travels to the specified map, passes along previously set options")</span>
<span class="err">+</span><span class="py">ManualAutoCompleteList</span><span class="p">=</span><span class="s">(Command="ServerTravel",Desc="&lt;MapName&gt; Travels to the specified map and brings clients along, passes along previously set options")</span>
</code></pre></div></div>

  </div></figure>

<p class="notice--warning"><strong>Note:</strong> Console commands aren’t case sensitive, so they can be written as desired: All capital/small letters, PascalCase, camelCase, etc.</p>

<h3 id="enabling-seamless-travel-and-transition-map" class="">Enabling Seamless Travel and Transition Map<a class="header-link" href="#enabling-seamless-travel-and-transition-map" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>To enable seamless travel, you need to setup a transition map. This is configured through the <code class="language-plaintext highlighter-rouge">UGameMapsSettings.TransitionMap</code> property. By default this property is empty, and if your game leaves this property empty, an empty map will be created for the transition map.</p>

<p>The reason the transition map exists, is that there must always be a world loaded (which holds the map), so we can’t free the old map before loading the new one. Since maps can be very large, it would be a bad idea to have the old and new map in memory at the same time, so this is where the transition map comes in.</p>

<p>So now we can travel from the current map to the transition map, and then from there we can travel to the final map. Since the transition map is very small, it doesn’t add much extra overhead while it overlaps the current and final map.</p>

<p>Once you have the transition map setup, you set <code class="language-plaintext highlighter-rouge">AGameModeBase.bUseSeamlessTravel</code> to true, and from there seamless travel should work.</p>

<p class="notice--warning"><strong>Note:</strong> Pre 5.1, seamless travel wasn’t supported in single process PIE (play-in-editor). Therefore, you had to either turn off <a href="https://docs.unrealengine.com/en-US/BuildingWorlds/LevelEditor/InEditorTesting/NetworkedPlayInEditor/#advancedsettings"><code class="language-plaintext highlighter-rouge">Run Under One Process</code></a> setting, or start a standalone (right click your .uproject and <code class="language-plaintext highlighter-rouge">Launch game</code>), or launch a packaged build. Since 5.1, seamless travel is supported in single process PIE, but you need to enable <a href="https://docs.unrealengine.com/en-US/console-varaibles-cplusplus-in-unreal-engine/">CVar</a> <code class="language-plaintext highlighter-rouge">net.AllowPIESeamlessTravel</code> from console command as it’s disabled by default.</p>

<h2 id="gameframework-objects" class="">
<a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Framework/">GameFramework</a> Objects<a class="header-link" href="#gameframework-objects" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>It’s quite important to get to know the <a href="https://www.tomlooman.com/unreal-engine-gameplay-framework/">Unreal gameplay framework objects</a>, their creation order, calls, and space. This will help us tackle a spectrum of issues, that not just necessarily related to persisting data.</p>

<p class="notice--primary"><strong>Tip:</strong> From now on, you’ll quite often see <code class="language-plaintext highlighter-rouge">AGameMode(Base)</code> which is my way of saying either <code class="language-plaintext highlighter-rouge">AGameModeBase</code> or <code class="language-plaintext highlighter-rouge">AGameMode</code>, based on which you subclass. Generally speaking, you should favor <code class="language-plaintext highlighter-rouge">AGameMode</code> as it has support for much more functionalities: Match states, disconnection bookkeeping, true persistence of <strong>PlayerController</strong> and its dependency <strong>Actors</strong>, etc.</p>

<h3 id="gameframework-objects-creation-order-and-calls" class="">GameFramework Objects Creation Order and Calls<a class="header-link" href="#gameframework-objects-creation-order-and-calls" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Most of the times, when we travel (regardless of the type) from one level to another, or when we disconnect and reconnect, <strong>Objects</strong> get <strong>destroyed</strong> and <strong>recreated</strong> (excluding <strong>GameInstance</strong>, and <strong>GameViewportClient</strong> which are created at game start and never destroyed until game shutdown), by the following order:</p>

<ol>
  <li>
<strong>GameInstance:</strong> In <strong>Standalone</strong> is created once on game start inside <code class="language-plaintext highlighter-rouge">UGameEngine::Init()</code>, and in <strong>PIE</strong> is created for each PIE instance inside <code class="language-plaintext highlighter-rouge">UEditorEngine::CreateInnerProcessPIEGameInstance()</code>. Same <strong>GameInstance</strong> is set to be used in the new loaded level inside <code class="language-plaintext highlighter-rouge">UEngine::LoadMap()</code>.</li>
  <li>
<strong>GameMode:</strong> Created by <strong>GameInstance</strong> when server loads the map inside <code class="language-plaintext highlighter-rouge">UGameInstance::CreateGameModeForURL()</code>, called by <code class="language-plaintext highlighter-rouge">UWorld::SetGameMode()</code>, called by <code class="language-plaintext highlighter-rouge">UEngine::LoadMap()</code>.</li>
  <li>
<strong>GameSession:</strong> Created by <strong>GameMode</strong> inside <code class="language-plaintext highlighter-rouge">AGameModeBase::InitGame()</code>.</li>
  <li>
<strong>GameState:</strong> Created by <strong>GameMode</strong> inside <code class="language-plaintext highlighter-rouge">AGameModeBase::PreInitializeComponents()</code>.</li>
  <li>
<strong>GameNetworkManager:</strong>  Created by <strong>GameMode</strong> inside <code class="language-plaintext highlighter-rouge">AGameModeBase::PreInitializeComponents()</code>.</li>
  <li>
<strong>PlayerController:</strong> Created by <strong>GameMode</strong>, either after a <a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess">successful login</a> inside <code class="language-plaintext highlighter-rouge">AGameModeBase::SpawnPlayerController()</code>, called by <code class="language-plaintext highlighter-rouge">AGameModeBase::Login()</code>, called by <code class="language-plaintext highlighter-rouge">UWorld::SpawnPlayActor()</code> in case of <strong>hard</strong> travel. However, in case of <strong>seamless</strong> travel: If the new <strong>GameMode’s</strong> class is a <strong>subclass</strong> of <code class="language-plaintext highlighter-rouge">AGameMode</code> <strong>and</strong> its <strong>PlayerController</strong> class is the <strong>same</strong> as the previous, then the same old <strong>PlayerController</strong> is kept, and none is created. Otherwise, they are <strong>different</strong> classes, and it’s created inside <code class="language-plaintext highlighter-rouge">AGameMode(Base)::HandleSeamlessTravelPlayer()</code>.</li>
  <li>
<strong>SpectatorPawn:</strong> Created by <strong>PlayerController</strong> inside <code class="language-plaintext highlighter-rouge">APlayerController::SpawnSpectatorPawn()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::BeginSpectatingState()</code>, which is either called by <code class="language-plaintext highlighter-rouge">APlayerController::ReceivedPlayer()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::SetPlayer()</code>, called by <code class="language-plaintext highlighter-rouge">UWorld::SpawnPlayActor()</code> in case of <strong>hard</strong> travel, or called by <code class="language-plaintext highlighter-rouge">APlayerController::ChangeState()</code>, called by <code class="language-plaintext highlighter-rouge">AGameMode(Base)::InitSeamlessTravelPlayer()</code>, called by <code class="language-plaintext highlighter-rouge">AGameMode(Base)::HandleSeamlessTravelPlayer()</code> in case of <strong>seamless</strong> travel.<br>
It’s destroyed (as soon as a <strong>Pawn</strong> is possessed) inside <code class="language-plaintext highlighter-rouge">APlayerController::DestroySpectatorPawn()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::ChangeState()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::OnPossess()</code>, called by <code class="language-plaintext highlighter-rouge">AController::Possess()</code>, called by <code class="language-plaintext highlighter-rouge">AGameModeBase::FinishRestartPlayer()</code>.</li>
  <li>
<strong>PlayerState:</strong> Created by <strong>PlayerController</strong> inside <code class="language-plaintext highlighter-rouge">AController::InitPlayerState()</code>, called by<code class="language-plaintext highlighter-rouge">APlayerController::PostInitializeComponents()</code> in case of player, and created by <strong>AIController</strong> inside <code class="language-plaintext highlighter-rouge">AController::InitPlayerState()</code>, called by <code class="language-plaintext highlighter-rouge">AAIController::PostInitializeComponents()</code>.</li>
  <li>
<strong>PlayerCameraManager:</strong> Created by <strong>PlayerController</strong> inside <code class="language-plaintext highlighter-rouge">APlayerController::SpawnPlayerCameraManager()</code> called by <code class="language-plaintext highlighter-rouge">APlayerController::PostInitializeComponents()</code>, either in case of <strong>hard</strong> travel, or in case of <strong>seamless</strong> travel and the new <strong>GameMode’s</strong> <strong>PlayerController</strong> class is <strong>different</strong> than the previous. Otherwise, in case of <strong>seamless</strong> travel and they are the <strong>same</strong> class: If the player is either a client or listen-server, the same old <strong>PlayerCameraManager</strong> is kept, and none is created. However, for a dedicated-server, it’s created inside <code class="language-plaintext highlighter-rouge">APlayerController::PostSeamlessTravel()</code>.</li>
  <li>
<strong>CheatManager:</strong> Created by <strong>PlayerController</strong> inside <code class="language-plaintext highlighter-rouge">APlayerController::AddCheats()</code>, called by either <code class="language-plaintext highlighter-rouge">APlayerController::PostInitializeComponents()</code> in case of PIE/single-player, or <code class="language-plaintext highlighter-rouge">EnableCheats()</code> in any other case but a shipping build.</li>
  <li>
<strong>HUD:</strong> Created by <strong>PlayerController</strong> inside <code class="language-plaintext highlighter-rouge">APlayerController::ClientSetHUD()</code>, called by <code class="language-plaintext highlighter-rouge">AGameModeBase::InitializeHUDForPlayer()</code>, called by <code class="language-plaintext highlighter-rouge">AGameModeBase::GenericPlayerInitialization()</code> which is called for both <strong>seamless</strong> and <strong>hard</strong> travels. In case of <strong>seamless</strong> travel, if the new <strong>GameMode’s</strong> class is a <strong>subclass</strong> of <code class="language-plaintext highlighter-rouge">AGameMode</code> <strong>and</strong> its <strong>PlayerController</strong> class is the <strong>same</strong> as the previous, the old <strong>HUD</strong> will be valid inside <code class="language-plaintext highlighter-rouge">APlayerController::ClientSetHUD()</code>, and will be destroyed before the new one is created (we will <a href="https://wizardcell.com/unreal/persistent-data/#persistent-hud-example">see below</a> how we can handle copying the data from the old instance to the new one or even make it truly persistent).</li>
  <li>
<strong>Pawn:</strong> Created by <strong>GameMode</strong> inside <code class="language-plaintext highlighter-rouge">AGameModeBase::RestartPlayer()</code>, called by <code class="language-plaintext highlighter-rouge">AGameMode(Base)::HandleStartingNewPlayer()</code>, called by either <code class="language-plaintext highlighter-rouge">AGameMode(Base)::PostLogin()</code> in case of <strong>hard</strong> travel, or <code class="language-plaintext highlighter-rouge">AGameMode(Base)::HandleSeamlessTravelPlayer()</code> in case of <strong>seamless</strong> travel.</li>
  <li>
<strong>AIController:</strong> Created by AI <strong>Pawn</strong> inside <code class="language-plaintext highlighter-rouge">APawn::SpawnDefaultController()</code>, called by <code class="language-plaintext highlighter-rouge">APawn::PostInitializeComponents()</code>.</li>
</ol>

<p class="notice--warning"><strong>Note:</strong> I’m not providing you with the full creation call stack, neither the whole <strong>Objects</strong> list, as that would be insane, but I’m shedding light on the interesting ones. For more detailed info, I suggest you watch <a href="https://youtu.be/IaU2Hue-ApI">Alex Forsythe’s video</a>.</p>

<p class="notice--primary"><strong>Tip:</strong> Use <code class="language-plaintext highlighter-rouge">AGameMode(Base)::HandleStartingNewPlayer()</code> as an entry function, as it’s called regardless of whether the travel was seamless or not.</p>

<h3 id="gameframework-objects-creation-space">GameFramework Objects Creation Space<a class="header-link" href="#gameframework-objects-creation-space" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p><strong>GameMode</strong>, <strong>GameSession</strong>, <strong>GameNetworkManager</strong> and <strong>AIController</strong> exist only on server.</p>

<p><strong>GameInstance</strong> and <strong>GameState</strong> exist on server and client, though the former isn’t replicated and the latter is.</p>

<p><strong>PlayerState</strong> and <strong>Pawn</strong> are replicated, existing for every (autonomous and simulated) proxy on server and client.</p>

<p><strong>PlayerController</strong> is replicated, existing on server for every proxy, and only on owning client (autonomous proxy).</p>

<p><strong>PlayerCameraManager</strong> exists for every proxy on server, and only on owning client, though isn’t replicated.</p>

<p><strong>SpectatorPawn</strong> and <strong>HUD</strong> exist only on owning client.</p>

<p><strong>CheatManager</strong> exists only on server, but can exist on owning client if the latter calls <code class="language-plaintext highlighter-rouge">APlayerController::EnableCheats()</code>.</p>

<p class="notice--warning"><strong>Note:</strong> Usually these <strong>Actor</strong> classes are different between two different maps (source and destination maps); therefore, if we want to persist data we need to have both child <strong>Actor</strong> classes inherit from a shared parent <strong>Actor</strong> class with the shared data inside it.</p>

<h2 id="persisting-data-across-seamless-travel">Persisting Data across Seamless Travel<a class="header-link" href="#persisting-data-across-seamless-travel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>The fact that traveling gets most of our <strong>Objects</strong> destroyed, makes the process of persisting runtime data a hard mission. Nevertheless, in this context, <strong>seamless</strong> travel can make our life much easier.</p>

<h3 id="seamless-travel-flow">Seamless Travel Flow<a class="header-link" href="#seamless-travel-flow" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ol>
  <li>Mark <strong>Actors</strong> that will persist to the transition level (inner non-Actor <strong>Objects</strong> will automatically persist too).</li>
  <li>Travel to the transition level.</li>
  <li>Mark <strong>Actors</strong> that will persist to the final level (inner non-Actor <strong>Objects</strong> will automatically persist too).</li>
  <li>Travel to the final level.</li>
</ol>

<h3 id="persistent-objects-on-server-to-transition-map-only" class="">Persistent Objects on Server to Transition Map only<a class="header-link" href="#persistent-objects-on-server-to-transition-map-only" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>When we <strong>seamless</strong> travel these <strong>Objects</strong> will persist by default to the transition map:</p>

<ul>
  <li><strong>GameMode</strong></li>
  <li><strong>GameSession</strong></li>
  <li><strong>GameState</strong></li>
  <li>Any non-Actor <strong>Objects</strong> that are inside any of the previously mentioned <strong>Actors</strong> (i.e. <code class="language-plaintext highlighter-rouge">Object.Outer == Actor</code>)</li>
</ul>

<p>See the function below for reference:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AGameModeBase</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get allocations for the elements we're going to add handled in one go</span>
    <span class="k">const</span> <span class="n">int32</span> <span class="n">ActorsToAddCount</span> <span class="o">=</span> <span class="n">GameState</span><span class="o">-&gt;</span><span class="n">PlayerArray</span><span class="p">.</span><span class="n">Num</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">bToTransition</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ActorList</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="n">ActorsToAddCount</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bToTransition</span><span class="p">)</span> <span class="c1">// true if we are going from old level to transition map, false if we are going from transition map to new level</span>
    <span class="p">{</span>
        <span class="c1">// Keep ourselves until we transition to the transition map</span>
        <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="c1">// Keep general game state until we transition to the transition map</span>
        <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">GameState</span><span class="p">);</span>
        <span class="c1">// Keep the game session state until we transition to the transition map</span>
        <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">GameSession</span><span class="p">);</span>

        <span class="c1">// If adding in this section best to increase the literal above for the ActorsToAddCount</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p class="notice--warning"><strong>Note:</strong> I fixed the comments inside the if block, as they originally stated that <strong>GameMode</strong>, <strong>GameState</strong>, and <strong>GameSession</strong> persist to the destination map, which is totally misleading. Also, note that the <a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/Travelling/#persistingactorsacrossseamlesstravel">docs</a> are misleading, as in fact they also state that the <strong>GameMode</strong> persists to the destination map, which is incorrect.</p>

<h4 id="should-they-be-kept-to-destination-map" class="">Should they be Kept to Destination Map?<a class="header-link" href="#should-they-be-kept-to-destination-map" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<p>While you can override the function above to keep those <strong>Actors</strong> to the destination map, I suggest you not to do so, for several reasons:</p>

<ol>
  <li>There should be no reason to persist runtime data in <strong>GameMode</strong>, as this class defines the game rules which are set at compile time.</li>
  <li>
<strong>GameMode</strong> class usually varies between two different levels, so keeping the same <strong>Actor</strong> is a bad idea.</li>
  <li>
    <p>Keeping one of these classes and not the others is like going down the rabbit hole. For example, keeping <strong>GameMode</strong> and not <strong>GameState</strong> will cause the server to shutdown, as these two classes are coupled, as you can see here:</p>

    <figcaption>
   <p class="figure-title">World.cpp</p>
 </figcaption>
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code> <span class="n">UWorld</span><span class="o">*</span> <span class="n">FSeamlessTravelHandler</span><span class="o">::</span><span class="n">Tick</span><span class="p">()</span>
 <span class="p">{</span>
     <span class="p">...</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">KeptGameMode</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">LoadedWorld</span><span class="o">-&gt;</span><span class="n">CopyGameState</span><span class="p">(</span><span class="n">KeptGameMode</span><span class="p">,</span> <span class="n">KeptGameState</span><span class="p">);</span>
         <span class="n">bCreateNewGameMode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="p">...</span>
 <span class="p">}</span>

 <span class="kt">void</span> <span class="n">UWorld</span><span class="o">::</span><span class="n">CopyGameState</span><span class="p">(</span><span class="n">AGameModeBase</span><span class="o">*</span><span class="n">FromGameMode</span><span class="p">,</span> <span class="n">AGameStateBase</span><span class="o">*</span> <span class="n">FromGameState</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">AuthorityGameMode</span> <span class="o">=</span> <span class="n">FromGameMode</span><span class="p">;</span>
     <span class="n">SetGameState</span><span class="p">(</span><span class="n">FromGameState</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Even if we kept both <strong>GameMode</strong> and <strong>GameState</strong>, our game will freeze, and there is no way to unfreeze it, unless we reconnect our clients.</li>
</ol>

<p class="notice--primary"><strong>Tip:</strong> Don’t persist runtime data with these <strong>Actor</strong> classes: <strong>GameMode</strong>, <strong>GameState</strong>, and <strong>GameSession</strong>.</p>

<h3 id="persistent-objects-on-server-to-destination-map">Persistent Objects on Server to Destination Map<a class="header-link" href="#persistent-objects-on-server-to-destination-map" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>By default, the following <strong>Objects</strong> will persist only on <strong>server</strong> to the destination map, though, sometimes they will be destroyed and recreated. Therefore, we’ll have to copy data (more on this below) over to the new created ones. Here’s the list:</p>

<ul>
  <li>All <strong>PlayerStates</strong>
</li>
  <li>All <strong>Controllers</strong> that have a valid <strong>PlayerState</strong> (including <strong>AIControllers</strong> that use <strong>PlayerStates</strong>)</li>
  <li>All <strong>PlayerControllers</strong>
</li>
  <li>Listen-server’s <strong>HUD</strong>
</li>
  <li>Listen-server’s <strong>PlayerCameraManager</strong>
</li>
  <li>All Listen-server’s <strong>UserWidgets</strong>
</li>
  <li>Any <strong>Actors</strong> further added via <code class="language-plaintext highlighter-rouge">APlayerController::GetSeamlessTravelActorList()</code> called on listen-server’s <strong>PlayerController</strong>
</li>
  <li>Any <strong>Actors</strong> further added via <code class="language-plaintext highlighter-rouge">AGameModeBase::GetSeamlessTravelActorList()</code>
</li>
  <li>Any non-Actor <strong>Objects</strong> that are inside an <strong>Actor</strong> that is in the list (i.e. <code class="language-plaintext highlighter-rouge">Object.Outer == Actor</code> in the list <code class="language-plaintext highlighter-rouge">ActorList</code>)</li>
  <li>Any <strong>Actors</strong> that have: <code class="language-plaintext highlighter-rouge">(Role &lt; ROLE_Authority) &amp;&amp; (NetDormancy &lt; DORM_DormantAll) &amp;&amp; (!IsNetStartupActor())</code>
</li>
</ul>

<p class="notice--warning"><strong>Note:</strong> Only dynamic <strong>Actors</strong> (assigned a dynamic <a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FNetworkGUID/">NetGUID</a>, and this includes but isn’t limited to all <strong>Actors</strong> spawned during gameplay) in the <strong>PersistentLevel</strong> may persist.</p>

<p>See the functions below for reference:</p>

<figure>
      <figcaption>
        <p class="figure-title">World.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">UWorld</span><span class="o">*</span> <span class="n">FSeamlessTravelHandler</span><span class="o">::</span><span class="n">Tick</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// mark actors we want to keep</span>
    <span class="n">FUObjectAnnotationSparseBool</span> <span class="n">KeepAnnotation</span><span class="p">;</span>
    <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;</span> <span class="n">KeepActors</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">AGameModeBase</span><span class="o">*</span> <span class="n">AuthGameMode</span> <span class="o">=</span> <span class="n">CurrentWorld</span><span class="o">-&gt;</span><span class="n">GetAuthGameMode</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">AuthGameMode</span><span class="o">-&gt;</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="o">!</span><span class="n">bSwitchedToDefaultMap</span><span class="p">,</span> <span class="n">KeepActors</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">bool</span> <span class="n">bIsClient</span> <span class="o">=</span> <span class="p">(</span><span class="n">CurrentWorld</span><span class="o">-&gt;</span><span class="n">GetNetMode</span><span class="p">()</span> <span class="o">==</span> <span class="n">NM_Client</span><span class="p">);</span>

    <span class="c1">// always keep Controllers that belong to players</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bIsClient</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="n">FConstControllerIterator</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="n">CurrentWorld</span><span class="o">-&gt;</span><span class="n">GetControllerIterator</span><span class="p">();</span> <span class="n">Iterator</span><span class="p">;</span> <span class="o">++</span><span class="n">Iterator</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">AController</span><span class="o">*</span> <span class="n">Player</span> <span class="o">=</span> <span class="n">Iterator</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">PlayerState</span> <span class="o">||</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">APlayerController</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Player</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">KeepAnnotation</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">Player</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ask players what else we should keep</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">FLocalPlayerIterator</span> <span class="n">It</span><span class="p">(</span><span class="n">GEngine</span><span class="p">,</span> <span class="n">CurrentWorld</span><span class="p">);</span> <span class="n">It</span><span class="p">;</span> <span class="o">++</span><span class="n">It</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span><span class="o">-&gt;</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="o">!</span><span class="n">bSwitchedToDefaultMap</span><span class="p">,</span> <span class="n">KeepActors</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// mark all valid actors specified</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">AActor</span><span class="o">*</span> <span class="n">KeepActor</span> <span class="o">:</span> <span class="n">KeepActors</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KeepActor</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">KeepAnnotation</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">KeepActor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AGameModeBase</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get allocations for the elements we're going to add handled in one go</span>
    <span class="k">const</span> <span class="n">int32</span> <span class="n">ActorsToAddCount</span> <span class="o">=</span> <span class="n">GameState</span><span class="o">-&gt;</span><span class="n">PlayerArray</span><span class="p">.</span><span class="n">Num</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">bToTransition</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ActorList</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="n">ActorsToAddCount</span><span class="p">);</span>

    <span class="c1">// Always keep PlayerStates, so that after we restart we can keep players on the same team, etc</span>
    <span class="n">ActorList</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">GameState</span><span class="o">-&gt;</span><span class="n">PlayerArray</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">PlayerController.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">APlayerController</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToEntry</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MyHUD</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">MyHUD</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Should player camera persist or just be recreated?  (clients have to recreate on host)</span>
    <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">PlayerCameraManager</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<h3 id="persistent-objects-on-client-to-destination-map" class="">Persistent Objects on Client to Destination Map<a class="header-link" href="#persistent-objects-on-client-to-destination-map" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>By default, the following <strong>Objects</strong> will persist only on <strong>client</strong> to the destination map, though, sometimes they will be destroyed and recreated. Therefore, we’ll have to copy data (more on this below) over to the new created ones. Here’s the list:</p>

<ul>
  <li>local <strong>PlayerController</strong>
</li>
  <li><strong>HUD</strong></li>
  <li>local <strong>PlayerCameraManager</strong>
</li>
  <li>All <strong>UserWidgets</strong>
</li>
  <li>Any <strong>Actors</strong> further added via <code class="language-plaintext highlighter-rouge">APlayerController::GetSeamlessTravelActorList()</code> called on local <strong>PlayerController</strong>
</li>
  <li>Any non-Actor <strong>Objects</strong> that are inside an <strong>Actor</strong> that is in the list (i.e. <code class="language-plaintext highlighter-rouge">Object.Outer == Actor</code> in the list)</li>
  <li>Any <strong>Actors</strong> that have: <code class="language-plaintext highlighter-rouge">(Role &lt; ROLE_Authority) &amp;&amp; (NetDormancy &lt; DORM_DormantAll) &amp;&amp; (!IsNetStartupActor())</code>
</li>
</ul>

<p class="notice--warning"><strong>Note:</strong> Only dynamic <strong>Actors</strong> in the <strong>PersistentLevel</strong> may persist.</p>

<p>See the function below for reference:</p>

<figure>
      <figcaption>
        <p class="figure-title">World.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">UWorld</span><span class="o">*</span> <span class="n">FSeamlessTravelHandler</span><span class="o">::</span><span class="n">Tick</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// mark actors we want to keep</span>
    <span class="n">FUObjectAnnotationSparseBool</span> <span class="n">KeepAnnotation</span><span class="p">;</span>
    <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;</span> <span class="n">KeepActors</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">bool</span> <span class="n">bIsClient</span> <span class="o">=</span> <span class="p">(</span><span class="n">CurrentWorld</span><span class="o">-&gt;</span><span class="n">GetNetMode</span><span class="p">()</span> <span class="o">==</span> <span class="n">NM_Client</span><span class="p">);</span>

    <span class="c1">// always keep Controllers that belong to players</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bIsClient</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">FLocalPlayerIterator</span> <span class="n">It</span><span class="p">(</span><span class="n">GEngine</span><span class="p">,</span> <span class="n">CurrentWorld</span><span class="p">);</span> <span class="n">It</span><span class="p">;</span> <span class="o">++</span><span class="n">It</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">KeepAnnotation</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">// ask players what else we should keep</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">FLocalPlayerIterator</span> <span class="n">It</span><span class="p">(</span><span class="n">GEngine</span><span class="p">,</span> <span class="n">CurrentWorld</span><span class="p">);</span> <span class="n">It</span><span class="p">;</span> <span class="o">++</span><span class="n">It</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">It</span><span class="o">-&gt;</span><span class="n">PlayerController</span><span class="o">-&gt;</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="o">!</span><span class="n">bSwitchedToDefaultMap</span><span class="p">,</span> <span class="n">KeepActors</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// mark all valid actors specified</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">AActor</span><span class="o">*</span> <span class="n">KeepActor</span> <span class="o">:</span> <span class="n">KeepActors</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KeepActor</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">KeepAnnotation</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">KeepActor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">PlayerController.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">APlayerController</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToEntry</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MyHUD</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">MyHUD</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Should player camera persist or just be recreated?  (clients have to recreate on host)</span>
    <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">PlayerCameraManager</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<h3 id="persistent-non-actor-objects-across-seamless-travel">Persistent non-Actor Objects across Seamless Travel<a class="header-link" href="#persistent-non-actor-objects-across-seamless-travel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p class="notice--danger"><strong>Caution:</strong> This section is still a WIP, and so you shouldn’t be taking my words for granted!</p>

<p>If you look closely at the <a href="https://wizardcell.com/unreal/persistent-data/#5-getseamlesstravelactorlist">docs</a> of a function like <code class="language-plaintext highlighter-rouge">GetSeamlessTravelActorList()</code> and read between the lines, you will quickly realize that apart from the persistent list of <strong>Actors</strong>, there are also non-Actor <strong>Objects</strong> that could potentially persist, due to this: <code class="language-plaintext highlighter-rouge">(i.e. Object.Outer == Actor in the list)</code>. In another context, I noticed that <strong>UserWidgets</strong> persist only <strong>seamless</strong> travels and they are usually outer’d to <strong>GameInstance</strong> (in case one doesn’t exist, they are outer’d to <strong>World</strong>), which is persistent regardless of the travel type. On the one hand, if one happens to change their <code class="language-plaintext highlighter-rouge">Outer</code> (via <code class="language-plaintext highlighter-rouge">UObject::Rename()</code>) to <strong>Pawn</strong> for example, which isn’t persistent by default, then they won’t persist anymore, while on the other hand, changing their <code class="language-plaintext highlighter-rouge">Outer</code> to a persistent <strong>PlayerController</strong> will keep them persistent.</p>

<p>This led me to the following theory:</p>
<blockquote>
  <p><strong>Upon seamless travel, any non-Actor Object that is outer’d to a persistent Object will also be persistent</strong>.</p>
</blockquote>

<p>One assumption to why this might be the case is that <code class="language-plaintext highlighter-rouge">Outer</code> holds a strong/hard reference to its inners, preventing them from being automatically <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Objects/Optimizations/#garbagecollection">GC’d</a> (garbage collected). Though, that’s not the case at all, and therefore the <code class="language-plaintext highlighter-rouge">Outer</code> of an inner <strong>Object</strong> has nothing to do with the lifetime of that inner from a GC perspective. However, inner holds a strong reference to its <code class="language-plaintext highlighter-rouge">Outer</code>, so as long as the inner is alive, its <code class="language-plaintext highlighter-rouge">Outer</code> will also be kept alive. An exception to this rule is <strong>UPackage</strong>. It is the root “thing” that actually gets saved and loaded by the engine, and therefore has no <code class="language-plaintext highlighter-rouge">Outer</code>. The <strong>Object</strong> outer’d to that <strong>Package</strong>, will be saved along with it, making the <code class="language-plaintext highlighter-rouge">Outer</code> relationship very important in this case.</p>

<p>The other assumption is that the GC ignores unreachable non-Actor <strong>Objects</strong> that are outer’d to a persistent <strong>Object</strong> upon <strong>seamless</strong> travels. I have yet to prove this is the case though.</p>

<h4 id="persistent-userwidgets" class="">Persistent UserWidgets<a class="header-link" href="#persistent-userwidgets" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<p>We’ve already come to mention that by default <strong>UserWidgets</strong> are usually outer’d to <strong>GameInstance</strong>, and that’s why they are persistent on <strong>seamless</strong> travel. With that said, it’s quite interesting to see how they are handled in <strong>hard</strong> travels.</p>

<p>During a <strong>hard</strong> travel, <code class="language-plaintext highlighter-rouge">UEngine::LoadMap()</code> gets called, and at some point the delegate <code class="language-plaintext highlighter-rouge">FWorldDelegates::LevelRemovedFromWorld</code> gets broadcasted. When a <strong>UserWidget</strong> has <code class="language-plaintext highlighter-rouge">UUserWidget::AddToViewport()</code> called on it, it internally calls <code class="language-plaintext highlighter-rouge">UUserWidget::AddToScreen()</code>, which binds the previous delegate to the function <code class="language-plaintext highlighter-rouge">UUserWidget::OnLevelRemovedFromWorld()</code>, which calls <code class="language-plaintext highlighter-rouge">UUserWidget::RemoveFromParent()</code> as can be seen down below:</p>

<figure>
      <figcaption>
        <p class="figure-title">UserWidget.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/**
 * Called when a top level widget is in the viewport and the world is potentially coming to and end. When this occurs,
 * it's not safe to keep widgets on the screen. We automatically remove them when this happens and mark them for pending kill.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnLevelRemovedFromWorld</span><span class="p">(</span><span class="n">ULevel</span><span class="o">*</span> <span class="n">InLevel</span><span class="p">,</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">InWorld</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">UserWidget.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">UUserWidget</span><span class="o">::</span><span class="n">OnLevelRemovedFromWorld</span><span class="p">(</span><span class="n">ULevel</span><span class="o">*</span> <span class="n">InLevel</span><span class="p">,</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">InWorld</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If the InLevel is null, it's a signal that the entire world is about to disappear, so</span>
    <span class="c1">// go ahead and remove this widget from the viewport, it could be holding onto too many</span>
    <span class="c1">// dangerous actor references that won't carry over into the next world.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">InLevel</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">InWorld</span> <span class="o">==</span> <span class="n">GetWorld</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RemoveFromParent</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>When a <strong>UserWidget</strong> gets destroyed, its underlying <a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Slate/InGameUI/"><strong>Slate</strong></a> <strong>Widget</strong> won’t be automatically removed from the viewport, hence the above function <code class="language-plaintext highlighter-rouge">OnLevelRemovedFromWorld()</code> ensures that for the stated reason.</p>

<p>To sum up, during <strong>hard</strong> travel <strong>UserWidgets</strong> get destroyed and so their underlying Slate <strong>Widget</strong>, while during <strong>seamless</strong> travel they will persist just fine.</p>

<h5 id="should-userwidgets-persist-seamless-travel">Should UserWidgets Persist Seamless Travel?<a class="header-link" href="#should-userwidgets-persist-seamless-travel" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h5>

<p>While reading through the previous section, you might have asked yourself if it’s a good practice for <strong>UserWidgets</strong> to be persisting a <strong>seamless</strong> travel, and the short answer to that is no. Reason being is that UI (User Interface) is for displaying state and accepting input. Causing it to carry that state past level loads turns it into the state holder and not the displayer. Therefore, <strong>UserWidgets</strong> should be mostly stateless (aside from visual effects required by the <strong>UserWidget</strong> itself for example), i.e. just mirroring data held elsewhere, and in return they should almost never need to persist.</p>

<p>There are multiple options to how you can prevent them from persisting, but here two:</p>

<ol>
  <li>
<u>Mimic what the engine does for <b>hard</b> travel:</u> Override <code class="language-plaintext highlighter-rouge">UUserWidget::AddToScreen()</code> (in a custom <code class="language-plaintext highlighter-rouge">UserWidgetBase</code> class, that every <strong>UserWidget</strong> inherits from) and listen for the delegate <code class="language-plaintext highlighter-rouge">FWorldDelegates::OnSeamlessTravelStart</code>, which calls a custom <code class="language-plaintext highlighter-rouge">UserWidgetBase::OnSeamlessTravelStart()</code> that calls an overridden <code class="language-plaintext highlighter-rouge">UUserWidgetBase::RemoveFromParent()</code>.</li>
  <li>
<u>Manually remove them when their manager <b>HUD</b> gets destroyed:</u> Override <code class="language-plaintext highlighter-rouge">AActor::Destroyed()</code> in your <strong>HUD</strong> class (great <strong>UserWidgets</strong> manager) and iterate through your <strong>UserWidgets</strong> and explicitly call <code class="language-plaintext highlighter-rouge">UUserWidget::RemoveFromParent()</code> on them.</li>
</ol>

<h3 id="meaning-of-persistent-objects">Meaning of Persistent Objects<a class="header-link" href="#meaning-of-persistent-objects" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>We have already seen that almost all <strong>Objects</strong>, including some of <a href="https://wizardcell.com/unreal/persistent-data/#persisting-objects-across-seamless-travel">those mentioned to be persistent</a>, get <a href="https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-order-and-calls">destroyed and recreated</a> by the time we <strong>seamless</strong> travel. If that’s the case, then how persistent <strong>Objects</strong> mentioned in the previous sections do really persist?</p>

<p>When a <strong>seamless</strong> travel occurs, there is a short period of time, where old and new instances of the specific <strong>Object</strong> class are alive.
In that period of time, only the data you choose to copy from old instance over to the new one, is what really gets kept. Therefore, the old <strong>Objects</strong> don’t really persist, but the data we choose to keep. However, this is not always the case. For example, <strong>UserWidgets</strong> (and any non-Actor <strong>Object</strong> that has a persistent <code class="language-plaintext highlighter-rouge">Outer</code>) do truly persist without needing to copy data over. Same goes for classes like <strong>PlayerController</strong> and <strong>PlayerCameraManager</strong>, but only if the new <strong>GameMode’s</strong> class is a <strong>subclass</strong> of <code class="language-plaintext highlighter-rouge">AGameMode</code> <strong>and</strong> its <strong>PlayerController</strong> class is the <strong>same</strong> as the previous. We will <a href="https://wizardcell.com/unreal/persistent-data/#5-getseamlesstravelactorlist">explain</a> the reasoning and how that’s done under the hood. The more thorough answer, and how the data keeping is done, is found in the next sections.</p>

<h2 id="persisting-data-across-disconnects">Persisting Data across Disconnects<a class="header-link" href="#persisting-data-across-disconnects" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>While the modern internet allows gamers to connect with each other all over the world, the internet is sometimes not as stable as we would like it to be. Disconnections occur on the daily basis in multiplayer games, and if not handled properly, players will suffer. Disconnecting and reconnecting is <a href="https://wizardcell.com/unreal/persistent-data/#travel-seamless-vs-hard">by definition</a> a <strong>hard</strong> travel, meaning we lack the benefits of <strong>seamless</strong> travel persistent data we discussed above. Luckily, Unreal has an already built in functionality that handles the data keeping of disconnecting and then reconnecting players, out of the box. To get how this functionality works all together, we should understand first how the engine handles a disconnecting player.</p>

<h3 id="storing-data-on-disconnection">Storing Data on Disconnection<a class="header-link" href="#storing-data-on-disconnection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Here’s the call stack (by order) for a player who disconnects, up to the point where his data is saved:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="mf">1.</span> <span class="n">APlayerController</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">()</span>
<span class="mf">2.</span> <span class="n">AController</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">()</span>
<span class="mf">3.</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">LogOut</span><span class="p">()</span>
<span class="mf">4.</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">AddInactivePlayer</span><span class="p">()</span>
<span class="mf">5.</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">Duplicate</span><span class="p">()</span>
<span class="mf">6.</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">DispatchCopyProperties</span><span class="p">()</span>
<span class="mf">7.</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">CopyProperties</span><span class="p">(),</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">ReceiveCopyProperties</span><span class="p">()</span> <span class="c1">// Native and Blueprint</span>
</code></pre></div></div>

<p class="notice--warning"><strong>Note:</strong> Your <strong>GameMode</strong> custom class must be inheriting from <code class="language-plaintext highlighter-rouge">AGameMode</code> instead of <code class="language-plaintext highlighter-rouge">AGameModeBase</code> as the latter has no support for such functionality.</p>

<p>Now in words, this what happens when a player disconnects from the game server :</p>

<ol>
  <li>His <strong>Pawn</strong> is unpossessed from the <strong>PlayerController</strong> and destroyed inside <code class="language-plaintext highlighter-rouge">APlayerController::PawnLeavingGame()</code>. <strong>SpectatorPawn</strong>, <strong>HUD</strong> and <strong>PlayerCameraManager</strong> are all destroyed too.</li>
  <li>
    <p>A new “copy” <strong>PlayerState</strong> is spawned, and data specified inside the native and Blueprint <code class="language-plaintext highlighter-rouge">CopyProperties()</code> functions, is copied over from the old original <strong>PlayerState</strong> to the newly created one. Override either one, and decide what data you want to copy accordingly. Here’s the data copied by default:</p>

    <figcaption>
   <p class="figure-title">PlayerState.cpp</p>
 </figcaption>
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code> <span class="kt">void</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">CopyProperties</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetScore</span><span class="p">(</span><span class="n">GetScore</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetCompressedPing</span><span class="p">(</span><span class="n">GetCompressedPing</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">ExactPing</span> <span class="o">=</span> <span class="n">ExactPing</span><span class="p">;</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetPlayerId</span><span class="p">(</span><span class="n">GetPlayerId</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetUniqueId</span><span class="p">(</span><span class="n">GetUniqueId</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetPlayerNameInternal</span><span class="p">(</span><span class="n">GetPlayerName</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetStartTime</span><span class="p">(</span><span class="n">GetStartTime</span><span class="p">());</span>
     <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SavedNetworkAddress</span> <span class="o">=</span> <span class="n">SavedNetworkAddress</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>The new copy <strong>PlayerState</strong> is then deactivated (not replicating anymore), and its lifespan is set to be <code class="language-plaintext highlighter-rouge">AGameMode.InactivePlayerStateLifeSpan</code> which is 300 seconds by default. If the player doesn’t reconnect by that time, their inactive stored copy <strong>PlayerState</strong> will be destroyed, and he won’t be able to reconnect again (as his <code class="language-plaintext highlighter-rouge">UniqueId</code> or <code class="language-plaintext highlighter-rouge">SavedNetworkAddress</code> is lost). Setting <code class="language-plaintext highlighter-rouge">InactivePlayerStateLifeSpan</code> to 0 will clear the timer, and the stored copy <strong>PlayerState</strong> won’t be destroyed. The inactive <strong>PlayerState</strong> is added to <code class="language-plaintext highlighter-rouge">AGameMode.InactivePlayerArray</code>, which is an array of <strong>PlayerStates</strong> belonging to players who have disconnected from the server, so they are saved in case they reconnect. Note that <code class="language-plaintext highlighter-rouge">AGameMode.MaxInactivePlayers</code> determines the maximum number of disconnected players before the older ones are kicked out.</li>
  <li>The original <strong>PlayerState</strong> is then destroyed inside <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::CleanupPlayerState()</code>, which in turn removes it from <code class="language-plaintext highlighter-rouge">AGameStateBase.PlayerArray</code> (array of all active <strong>PlayerStates</strong>) inside <code class="language-plaintext highlighter-rouge">APlayerState::Destroyed()</code>. The owning <strong>PlayerController</strong> is destroyed afterwards.</li>
</ol>

<p class="notice--warning"><strong>Note:</strong> By default, one of the conditions of which the <strong>PlayerState</strong> is duplicated and copied, is if <code class="language-plaintext highlighter-rouge">APlayerState.bOnlySpectator == false</code> for the disconnecting player, which means he didn’t join the server as a <a href="https://wizardcell.com/unreal/spectating-system/">spectator</a>.</p>

<p>With all that being said, there are two pitfalls, which we will cover in the next section.</p>

<h3 id="the-pitfalls">The Pitfalls<a class="header-link" href="#the-pitfalls" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p><strong>(1)</strong> Thanks to my friend <a href="https://www.linkedin.com/in/josip-duvancic-933934254/">Zlo</a> for his insight on the first pitfall. Quoting him:</p>

<blockquote>
  <p>While it seems <code class="language-plaintext highlighter-rouge">APlayerState::CopyProperties()</code> is the function to stash any data on disconnection, in fact it’s not, as you are likely going to need to pull some pawn-related data, which in order to restore it properly on reconnection, that function fails to do so.</p>

  <p>For example, suppose you want disconnected pawns to reappear on the spot where they disconnected. That requires the <strong>PlayerState</strong> to know the <strong>Pawn’s</strong> location by the time he disconnects, which it often doesn’t. Same goes for your inventory or skill systems, which even if you had the foresight to put them inside the <strong>PlayerState</strong> class, <code class="language-plaintext highlighter-rouge">CopyProperties()</code> remains to be an issue.</p>

  <p>For <code class="language-plaintext highlighter-rouge">CopyProperties()</code> to work, <strong>PlayerState</strong> has to have all the data you need already, and for disconnection purposes, it usually doesn’t. Therefore, you need a function that gets called at a later point in time. <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code> is the one.</p>
</blockquote>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Called on the server when the owning player has disconnected, by default this method destroys this player state */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnDeactivated</span><span class="p">();</span>
</code></pre></div></div>


  </div></figure>

<p><strong>(2)</strong> While it is common for an <strong>Actor</strong> to have its own <a href="https://docs.unrealengine.com/5.0/en-US/gameplay-ability-system-component-and-gameplay-attributes-in-unreal-engine/"><strong>AbilitySystemComponent</strong></a>, there are cases in which you might want an <strong>Actor</strong>, such as a player’s <strong>Pawn</strong>, to use an <strong>AbilitySystemComponent</strong> owned by another <strong>Actor</strong>, like a <strong>PlayerState</strong> or <strong>PlayerController</strong>. Reasons for this may include things like a player’s score, or long-lasting ability cooldown timers that do not reset when the player’s <strong>Pawn</strong> is destroyed and respawned, or when the player possesses a new <strong>Pawn</strong>.</p>

<p>For the said reason, and for disconnection purposes, we will attach the <strong>AbilitySystemComponent</strong> to <strong>PlayerState</strong>. However, as soon as we try to duplicate our <strong>PlayerState</strong>, we will find out that the <strong>AbilitySystemComponent’s</strong> <strong>AttributeSets</strong> are being set to <code class="language-plaintext highlighter-rouge">nullptr</code> instead of the proper value, and it turns out to be an <a href="https://issues.unrealengine.com/issue/UE-81109">engine bug</a>. While there are <a href="https://github.com/tranek/GASDocumentation#94-duplicating-blueprint-actors-is-setting-attributesets-to-nullptr">workarounds</a> to this, in my opinion the proper and easy fix is to make our original <strong>PlayerState</strong> stick around, without creating any duplicates. This also saves us some time spent on copying <strong>PlayerState</strong> related properties to the duplicate, especially when there are too many of them, making us less error-prone.</p>

<h3 id="the-better-more-reliable-way-to-stash-data-on-disconnection" class="">The Better, More Reliable Way to Stash Data on Disconnection<a class="header-link" href="#the-better-more-reliable-way-to-stash-data-on-disconnection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>While the properties you want to stash on disconnection can be scattered all over the <strong>PlayerState</strong> class, the much more decent, optimal way is to encapsulate them using a struct. That way, even when there’s a big pile of data we want to save, we can still refer to them quite fast.</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="c1">// Disconnected hero's non-PlayerState related data will be stored here</span>
<span class="n">USTRUCT</span><span class="p">()</span>
<span class="k">struct</span> <span class="nc">FDisconnectedHeroData</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>

    <span class="cm">/** Hero's transform (location, rotation, scale) */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FTransform</span> <span class="n">Transform</span><span class="p">;</span>

    <span class="cm">/** Hero's health */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">int32</span> <span class="n">Health</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">AMyPlayerState</span><span class="o">:</span> <span class="k">public</span> <span class="n">APlayerState</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>
    <span class="cm">/** Disconnected player's stashed data, so we reapply it on reconnection */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FDisconnectedHeroData</span> <span class="n">DisconnectedHeroData</span><span class="p">;</span>

    <span class="p">...</span>

<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<p>For us to be able to pull pawn-related data inside <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code>, the pawn has to be valid and possessed at that time. However, the <strong>Pawn</strong> is unposseded and destroyed before <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code> or even <code class="language-plaintext highlighter-rouge">APlayerState::CopyProperties()</code> are called. Specifically, it gets destroyed in the following function:</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerController.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">APlayerController</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GetPawn</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Handle players leaving the game</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Player</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">GetLocalRole</span><span class="p">()</span> <span class="o">==</span> <span class="n">ROLE_Authority</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PawnLeavingGame</span><span class="p">();</span> <span class="c1">// Destroys our pawn</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">UnPossess</span><span class="p">();</span> <span class="c1">// Unpossess our pawn, nulling out APlayerState.PawnPrivate</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">...</span>

    <span class="n">Super</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>For that reason, we have to override said function to neither destroy the <strong>Pawn</strong> nor unpossess it, and instead delegate the functionality to <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code>, which gets called at a later stage:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerController.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyPlayerController</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GetSpectatorPawn</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DestroySpectatorPawn</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">MyHUD</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MyHUD</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span>
        <span class="n">MyHUD</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PlayerCameraManager</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PlayerCameraManager</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span>
        <span class="n">PlayerCameraManager</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Tells the game info to forcibly remove this player's CanUnpause delegates from its list of Pausers.</span>
    <span class="c1">// Prevents the game from being stuck in a paused state when a PC that paused the game is destroyed before the game is unpaused.</span>
    <span class="n">AGameModeBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">GameMode</span> <span class="o">=</span> <span class="n">GetWorld</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetAuthGameMode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GameMode</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">GameMode</span><span class="o">-&gt;</span><span class="n">ForceClearUnpauseDelegates</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">PlayerInput</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">CheatManager</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Super</span><span class="o">::</span><span class="n">Super</span><span class="o">::</span><span class="n">Destroyed</span><span class="p">();</span> <span class="c1">// or AController::Destroyed();</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Moving on, we override <code class="language-plaintext highlighter-rouge">AGameMode::AddInactivePlayer()</code> so it doesn’t duplicate our original <strong>PlayerState</strong> (i.e. <code class="language-plaintext highlighter-rouge">APlayerState::Duplicate()</code> isn’t called, and <code class="language-plaintext highlighter-rouge">APlayerState::CopyProperties()</code> accordingly), but instead we make it stick around:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyGameMode.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Add PlayerState to the inactive list, remove from the active list */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">AddInactivePlayer</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">*</span> <span class="n">PC</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">MyGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyGameMode</span><span class="o">::</span><span class="n">AddInactivePlayer</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">*</span> <span class="n">PC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="n">PlayerState</span><span class="p">)</span>
    <span class="n">UWorld</span><span class="o">*</span> <span class="n">LocalWorld</span> <span class="o">=</span> <span class="n">GetWorld</span><span class="p">();</span>
    <span class="c1">// don't store if it's an old PlayerState from the previous level or if it's a spectator... or if we are shutting down</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">IsFromPreviousLevel</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MustSpectate</span><span class="p">(</span><span class="n">PC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">LocalWorld</span><span class="o">-&gt;</span><span class="n">bIsTearingDown</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We remove the PlayerState from the active PlayerArray as it's going to stick around (see APlayerState::Destroyed)</span>
        <span class="n">GameState</span><span class="o">-&gt;</span><span class="n">RemovePlayerState</span><span class="p">(</span><span class="n">PlayerState</span><span class="p">);</span>

        <span class="c1">// make PlayerState inactive</span>
        <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetReplicates</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

        <span class="c1">// delete after some time</span>
        <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SetLifeSpan</span><span class="p">(</span><span class="n">InactivePlayerStateLifeSpan</span><span class="p">);</span>

        <span class="c1">// On console, we have to check the unique net id as network address isn't valid</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">bIsConsole</span> <span class="o">=</span> <span class="o">!</span><span class="n">PLATFORM_DESKTOP</span><span class="p">;</span>
        <span class="c1">// Assume valid unique ids means comparison should be via this method</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">bHasValidUniqueId</span> <span class="o">=</span> <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">GetUniqueId</span><span class="p">().</span><span class="n">IsValid</span><span class="p">();</span>
        <span class="c1">// Don't accidentally compare empty network addresses (already issue with two clients on same machine during development)</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">bHasValidNetworkAddress</span> <span class="o">=</span> <span class="o">!</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SavedNetworkAddress</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">();</span>
        <span class="k">const</span> <span class="kt">bool</span> <span class="n">bUseUniqueIdCheck</span> <span class="o">=</span> <span class="n">bIsConsole</span> <span class="o">||</span> <span class="n">bHasValidUniqueId</span><span class="p">;</span>

        <span class="c1">// make sure no duplicates</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int32</span> <span class="n">Idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Idx</span> <span class="o">&lt;</span> <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">Num</span><span class="p">();</span> <span class="o">++</span><span class="n">Idx</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">APlayerState</span><span class="o">*</span> <span class="k">const</span> <span class="n">CurrentPlayerState</span> <span class="o">=</span> <span class="n">InactivePlayerArray</span><span class="p">[</span><span class="n">Idx</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsValid</span><span class="p">(</span><span class="n">CurrentPlayerState</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="c1">// already destroyed, just remove it</span>
                <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="n">Idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">Idx</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">bUseUniqueIdCheck</span> <span class="o">&amp;&amp;</span> <span class="n">bHasValidNetworkAddress</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CurrentPlayerState</span><span class="o">-&gt;</span><span class="n">SavedNetworkAddress</span> <span class="o">==</span>
                    <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">SavedNetworkAddress</span><span class="p">))</span>
                <span class="o">||</span> <span class="p">(</span><span class="n">bUseUniqueIdCheck</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CurrentPlayerState</span><span class="o">-&gt;</span><span class="n">GetUniqueId</span><span class="p">()</span> <span class="o">==</span> <span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">GetUniqueId</span><span class="p">())))</span>
            <span class="p">{</span>
                <span class="c1">// destroy the PlayerState, then remove it from the tracking</span>
                <span class="n">CurrentPlayerState</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span>
                <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="n">Idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">Idx</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">PlayerState</span><span class="p">);</span>

        <span class="c1">// make sure we don't go over the maximum number of inactive players allowed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">Num</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">MaxInactivePlayers</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">int32</span> <span class="k">const</span> <span class="n">NumToRemove</span> <span class="o">=</span> <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">Num</span><span class="p">()</span> <span class="o">-</span> <span class="n">MaxInactivePlayers</span><span class="p">;</span>

            <span class="c1">// destroy the extra inactive players</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">Idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Idx</span> <span class="o">&lt;</span> <span class="n">NumToRemove</span><span class="p">;</span> <span class="o">++</span><span class="n">Idx</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">APlayerState</span><span class="o">*</span> <span class="k">const</span> <span class="n">PS</span> <span class="o">=</span> <span class="n">InactivePlayerArray</span><span class="p">[</span><span class="n">Idx</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PS</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">PS</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// and then remove them from the tracking array</span>
            <span class="n">InactivePlayerArray</span><span class="p">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NumToRemove</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Next, we override <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code>, which by default destroys our original <strong>PlayerState</strong>, so it doesn’t do so, and in which we will populate our <code class="language-plaintext highlighter-rouge">FDisconnectedHeroData</code> struct exclusively:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyPlayerState</span><span class="o">::</span><span class="n">OnDeactivated</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">AMyPawn</span><span class="o">*</span> <span class="n">MyPawn</span> <span class="o">=</span> <span class="n">GetPawn</span><span class="o">&lt;</span><span class="n">AMyPawn</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">DisconnectedHeroData</span><span class="p">.</span><span class="n">Transform</span> <span class="o">=</span> <span class="n">MyPawn</span><span class="o">-&gt;</span><span class="n">GetTransform</span><span class="p">();</span>
        <span class="n">DisconnectedHeroData</span><span class="p">.</span><span class="n">Health</span> <span class="o">=</span> <span class="n">MyPawn</span><span class="o">-&gt;</span><span class="n">GetHealth</span><span class="p">();</span>
        <span class="c1">// Further pawn-related data can be pulled and stashed in here</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">PC</span> <span class="o">=</span> <span class="n">GetPlayerController</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Handle players leaving the game</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PC</span><span class="o">-&gt;</span><span class="n">Player</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PC</span><span class="o">-&gt;</span><span class="n">PawnLeavingGame</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">PC</span><span class="o">-&gt;</span><span class="n">UnPossess</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Last but not least, when a <a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess">player logs back in</a>, we will have to tell if he’s a reconnecting player, so we respawn him at his old <strong>Transform</strong>:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="nl">private:</span>
<span class="cm">/** Means this PlayerState belongs to a reconnecting player */</span>
<span class="n">uint8</span> <span class="n">bIsReconnecting</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="cm">/** Gets the literal value of bIsReconnecting. */</span>
<span class="kt">bool</span> <span class="n">IsReconnecting</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bIsReconnecting</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Called on the server when the owning player has reconnected and this player state is added to the active players array */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnReactivated</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyPlayerState</span><span class="o">::</span><span class="n">OnReactivated</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">bIsReconnecting</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>By default, a starting new player is always spawned at a <strong>PlayerStart</strong>. Instead, we make him spawn at his old <strong>Transform</strong>, in case he was reconnecting:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyGameMode.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Tries to spawn the player's pawn, either at his old location in case he's reconnecting, or at the location returned by FindPlayerStart */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">RestartPlayer</span><span class="p">(</span><span class="n">AController</span><span class="o">*</span> <span class="n">NewPlayer</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">MyGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyGameMode</span><span class="o">::</span><span class="n">RestartPlayer</span><span class="p">(</span><span class="n">AController</span><span class="o">*</span> <span class="n">NewPlayer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NewPlayer</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">NewPlayer</span><span class="o">-&gt;</span><span class="n">IsPendingKillPending</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">AMyPlayerState</span><span class="o">*</span> <span class="n">PS</span> <span class="o">=</span> <span class="n">NewPlayer</span><span class="o">-&gt;</span><span class="n">GetPlayerState</span><span class="o">&lt;</span><span class="n">AMyPlayerState</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">PS</span> <span class="o">&amp;&amp;</span> <span class="n">PS</span><span class="o">-&gt;</span><span class="n">IsReconnecting</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">RestartPlayerAtTransform</span><span class="p">(</span><span class="n">NewPlayer</span><span class="p">,</span> <span class="n">PS</span><span class="o">-&gt;</span><span class="n">DisconnectedHeroData</span><span class="p">.</span><span class="n">Transform</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">AActor</span><span class="o">*</span> <span class="n">StartSpot</span> <span class="o">=</span> <span class="n">FindPlayerStart</span><span class="p">(</span><span class="n">NewPlayer</span><span class="p">);</span>

        <span class="c1">// If a start spot wasn't found,</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">StartSpot</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Check for a previously assigned spot</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">NewPlayer</span><span class="o">-&gt;</span><span class="n">StartSpot</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">StartSpot</span> <span class="o">=</span> <span class="n">NewPlayer</span><span class="o">-&gt;</span><span class="n">StartSpot</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>
                <span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogGameMode</span><span class="p">,</span> <span class="n">Warning</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"RestartPlayer: Player start not found, using last start spot"</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">RestartPlayerAtPlayerStart</span><span class="p">(</span><span class="n">NewPlayer</span><span class="p">,</span> <span class="n">StartSpot</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<h3 id="restoring-data-on-reconnection" class="">Restoring Data on Reconnection<a class="header-link" href="#restoring-data-on-reconnection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Here’s the call stack (by order) for a player who reconnects, up to the point where his data is overridden:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="mf">1.</span> <span class="n">UWorld</span><span class="o">::</span><span class="n">SpawnPlayActor</span><span class="p">()</span>
<span class="mf">2.</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">Login</span><span class="p">(),</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">PostLogin</span><span class="p">()</span>
<span class="mf">3.</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">FindInactivePlayer</span><span class="p">()</span>
<span class="mf">4.</span> <span class="n">AGameMode</span><span class="o">::</span><span class="n">OverridePlayerState</span><span class="p">()</span>
<span class="mf">5.</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">DispatchOverrideWith</span><span class="p">()</span>
<span class="mf">6.</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">OverrideWith</span><span class="p">(),</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">ReceiveOverrideWith</span><span class="p">()</span> <span class="c1">// Native and Blueprint</span>
</code></pre></div></div>

<p>Now in words, this is part of <a href="https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-order-and-calls">what happens</a> when a player logs back into the game server :</p>

<ol>
  <li>A new <strong>PlayerController</strong> and <strong>Pawn</strong> (which becomes possessed by the former) are recreated for him by <strong>GameMode</strong>.</li>
  <li>A new <strong>PlayerState</strong>, <strong>PlayerCameraManager</strong> and <strong>HUD</strong> are recreated for him by <strong>PlayerController</strong>.</li>
  <li>The original inactive <strong>PlayerState</strong> <code class="language-plaintext highlighter-rouge">CurrentPlayerState</code> is retrieved and set to be our used <strong>PlayerState</strong>. It is then owned back by our newly created <strong>PlayerController</strong>, reactivated, its lifespan timer is cleared and it’s set not to be destroyed.</li>
  <li>Now looking at the local variable <code class="language-plaintext highlighter-rouge">OldPlayerState</code>, as its name suggests, one may guess it’s assigned the old/original inactive <strong>PlayerState</strong>. What makes such an assumption even more legitimate is the fact that it is being passed to <code class="language-plaintext highlighter-rouge">AGameMode::OverridePlayerState()</code>, which in turn passes it at some point to <code class="language-plaintext highlighter-rouge">APlayerState::ReceiveOverrideWith()</code> which its documentation suggests the following:</li>
</ol>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/*
 * Can be implemented in Blueprint Child to move more properties from old to new PlayerState when reconnecting
 *
 * @param OldPlayerState     Old PlayerState, which we use to fill the new one with
 */</span>
<span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintImplementableEvent</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="n">PlayerState</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">DisplayName</span> <span class="o">=</span> <span class="s">"OverrideWith"</span><span class="p">))</span>
<span class="kt">void</span> <span class="nf">ReceiveOverrideWith</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">OldPlayerState</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<p>While in fact the local variable <code class="language-plaintext highlighter-rouge">OldPlayerState</code> is assigned the freshly spawned, “empty” <strong>PlayerState</strong>. Therefore, <code class="language-plaintext highlighter-rouge">AGameMode::OverridePlayerState()</code> is called on our original just activated <strong>PlayerState</strong>, passing in the “pointlessly” spawned, almost empty <strong>PlayerState</strong>. Here’s what gets overridden in the process:</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">OverrideWith</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetIsSpectator</span><span class="p">(</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">IsSpectator</span><span class="p">());</span>
    <span class="n">SetIsOnlyASpectator</span><span class="p">(</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">IsOnlyASpectator</span><span class="p">());</span>
    <span class="n">SetUniqueId</span><span class="p">(</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">GetUniqueId</span><span class="p">());</span>
    <span class="n">SetPlayerNameInternal</span><span class="p">(</span><span class="n">PlayerState</span><span class="o">-&gt;</span><span class="n">GetPlayerName</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>As you can see, what gets overridden is so marginal, that most probably is important for the reconnection process.<br>
In theory, you could be using this function to override other types of data that could be outdated by the time that the player has reconnected. For example, when teams switch sides. If such case isn’t handled properly, the reconnected player might find himself in the wrong team!</p>

<p>Lastly, the almost empty <code class="language-plaintext highlighter-rouge">OldPlayerState</code> then calls <code class="language-plaintext highlighter-rouge">SetIsInactive(true)</code>, which in turn calls <code class="language-plaintext highlighter-rouge">APlayerState::OnRep_bIsInactive()</code>, preventing it from registering with <code class="language-plaintext highlighter-rouge">AGameStateBase.PlayerArray</code>. <code class="language-plaintext highlighter-rouge">OldPlayerState</code> is then destroyed, and the original, just reactivated <strong>PlayerState</strong> calls <code class="language-plaintext highlighter-rouge">APlayerState::OnReactivated()</code> which does nothing by default, though we’ve made a good use with it above.</p>

<p class="notice--warning"><strong>Note:</strong> Unfortunately, the current way to match players with their previous <strong>PlayerState</strong> is by comparing their IP addresses. If multiple players are playing with the same remote IP address, the wrong player could take over another disconnected player on their network. Oddly, this doesn’t affect console builds, as they check the player’s <code class="language-plaintext highlighter-rouge">PlayerState.UniqueId</code> (referred as <code class="language-plaintext highlighter-rouge">UniqueNetId</code> in <strong>OnlineSubsystems</strong>), which is a better unique identifier. The default OSS is <strong>OnlineSubsystemNull</strong> which has no valid <code class="language-plaintext highlighter-rouge">UniqueNetId</code>, that’s why a backend with unique users is needed, i.e., <code class="language-plaintext highlighter-rouge">APlayerState::GetUniqueId()</code> is only relevant/consistent if you have an OSS loaded such as <strong>Steam</strong> or <strong>EOS</strong>.</p>

<h3 id="how-to-disconnectreconnect">How to Disconnect/Reconnect?<a class="header-link" href="#how-to-disconnectreconnect" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>In theory, there could be multiple ways of implementing such functionalities. Thankfully, Unreal already has those functionalities implemented as console commands. Some of the commands we type in the console command-line is parsed at some point inside the following function:</p>

<figure>
      <figcaption>
        <p class="figure-title">UnrealEngine.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">bool</span> <span class="n">UEngine</span><span class="o">::</span><span class="n">Exec</span><span class="p">(</span> <span class="n">UWorld</span><span class="o">*</span><span class="n">InWorld</span><span class="p">,</span> <span class="k">const</span> <span class="n">TCHAR</span><span class="o">*</span> <span class="n">Cmd</span><span class="p">,</span> <span class="n">FOutputDevice</span><span class="o">&amp;</span> <span class="n">Ar</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">FParse</span><span class="o">::</span><span class="n">Command</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">Cmd</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"DISCONNECT"</span><span class="p">))</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">HandleDisconnectCommand</span><span class="p">(</span> <span class="n">Cmd</span><span class="p">,</span> <span class="n">Ar</span><span class="p">,</span> <span class="n">InWorld</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">FParse</span><span class="o">::</span><span class="n">Command</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">Cmd</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"RECONNECT"</span><span class="p">))</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">HandleReconnectCommand</span><span class="p">(</span> <span class="n">Cmd</span><span class="p">,</span> <span class="n">Ar</span><span class="p">,</span> <span class="n">InWorld</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<ul>
  <li>
<strong>DISCONNECT</strong>: Disconnects the client from the current game/server. It corresponds to the native function <code class="language-plaintext highlighter-rouge">UEngine::HandleDisconnectCommand()</code>, which calls <code class="language-plaintext highlighter-rouge">UEngine::HandleDisconnect()</code>. Disconnection is in fact a travel of type <strong>Absolute</strong> or <strong>Partial</strong> (depending on the disconnection circumstances) which in either case results in <strong>hard</strong> travel.</li>
  <li>
<strong>RECONNECT</strong>: Reconnects the client to the current game/server. It corresponds to the native function <code class="language-plaintext highlighter-rouge">UEngine::HandleReconnectCommand()</code>. Disconnection is in fact a travel of type <strong>Absolute</strong>, which results in <strong>hard</strong> travel.</li>
</ul>

<p class="notice--warning"><strong>Note:</strong> Those commands aren’t autocompleted like the travel-related ones we’ve seen earlier, as they don’t have <code class="language-plaintext highlighter-rouge">ManualAutoCompleteList</code> set for them.</p>

<p>Here is a couple of places you can choose from, to perform the functionalities above in code:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">UKismetSystemLibrary::ExecuteConsoleCommand()</code> native function (the Blueprint version has the same name) and <code class="language-plaintext highlighter-rouge">Command</code> parameter be either <code class="language-plaintext highlighter-rouge">DISCONNECT</code> or <code class="language-plaintext highlighter-rouge">RECONNECT</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">UGameInstance::Exec()</code> function and <code class="language-plaintext highlighter-rouge">Cmd</code> parameter be either <code class="language-plaintext highlighter-rouge">DISCONNECT</code> or <code class="language-plaintext highlighter-rouge">RECONNECT</code>.</li>
</ul>

<h2 id="persistent-runtime-data">Persistent Runtime Data<a class="header-link" href="#persistent-runtime-data" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Luckily there are multiple options to consider, when it comes to saving our data across level changes or reconnects. Note that the <strong>Usage</strong> section in each and everyone of these options reflects my own point of view; thus, you can deviate from the script. As a rule of thumb, I tend to store server-authoritative data server-side, and client-authoritative data client-side. However, sometimes server-authoritative data is intuitively stored client-side, forcing us to validate data when retrieved and before being applied.</p>

<h2 id="1-gameinstance">1. GameInstance<a class="header-link" href="#1-gameinstance" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>The <strong>GameInstance</strong> is a high-level manager <strong>Object</strong> for an instance of the running game. Spawned at game creation and not destroyed until game instance is shut down. In other words, the <strong>GameInstance</strong> persists from level-to-level, regardless of the travel type, making it a good candidate to save data. Running as a standalone game, there will be one of these. Running in PIE will generate one of these per PIE instance.</p>

<h3 id="how-to-specify-my-custom-class">How to Specify My Custom Class?<a class="header-link" href="#how-to-specify-my-custom-class" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>You can already tell that it shouldn’t be in the <code class="language-plaintext highlighter-rouge">Classes</code> category inside your custom <strong>GameMode’s</strong> <code class="language-plaintext highlighter-rouge">Class Defaults</code>, since the <strong>GameInstance</strong> isn’t level specific, and so it isn’t tied to a <strong>GameMode</strong>.</p>

<p>To configure your project to use your desired custom <strong>GameInstance</strong>, look into <code class="language-plaintext highlighter-rouge">Project Settings-&gt;Maps &amp; Modes</code>, and you should see this at the very bottom:</p>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/game-instance-configuration.png" alt="GameInstance Configuration" class="align-center"></p>

<h3 id="where-does-this-class-exist">Where does this Class Exist?<a class="header-link" href="#where-does-this-class-exist" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>This class exists on both server and client, though it isn’t replicable; thus, you can’t be replicating any data inside this class.</p>

<h3 id="saving--retrieving-data">Saving &amp; Retrieving Data<a class="header-link" href="#saving--retrieving-data" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>This is probably the easiest method, as all you have to do is simply save the data before traveling to a new level, and retrieve the saved data after you’re done traveling to that level. As for disconnection, it’s not any different. A reconnecting player, is in fact a player traveling to the map he was in. We have already <a href="https://wizardcell.com/unreal/persistent-data/#the-pitfalls">seen</a> that <code class="language-plaintext highlighter-rouge">APlayerState::OnDeactivated()</code> is a good point in time for saving data on disconnection; therefore, pull the data you need there, and hook it up in your <strong>GameInstance</strong>. When a client disconnects, his client-side <strong>GameInstance</strong> remains in memory on his own local machine. Upon reconnection, data can be retrieved, validated and reapplied where needed.</p>

<h3 id="usage">Usage<a class="header-link" href="#usage" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Persist world-state data between levels upon <strong>hard</strong> travels.</li>
  <li>Stash player-specific data on disconnection, and retrieve it on reconnection.</li>
</ul>

<p class="notice--primary"><strong>Tip:</strong> Consider using the <a href="https://wizardcell.com/unreal/persistent-data/#2-programming-subsystems">next option</a> instead.</p>

<h2 id="2-programming-subsystems" class="">2. Programming Subsystems<a class="header-link" href="#2-programming-subsystems" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Subsystems in Unreal are automatically instanced classes with managed lifetimes. These classes provide easy to use extension points, where programmers can get Blueprint and Python exposure right away while avoiding the complexity of modifying or overriding engine classes. Subsystems don’t support networking, hence you shouldn’t be replicating any data inside them directly. More info on them, and why they are useful can be found either in the <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/">offical docs</a> or in <a href="https://benui.ca/unreal/subsystem-singleton/">benui’s blog post</a>.</p>

<h3 id="where-does-this-class-exist-1">Where does this Class Exist?<a class="header-link" href="#where-does-this-class-exist-1" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>As you might have already seen, there are 5 different parent classes to choose from. Though, we’ll shed light on those used in this context: <strong>GameInstance</strong> and <strong>LocalPlayer</strong> subsystems. Both have an almost similar (not identical) lifecycle to the one the <a href="https://wizardcell.com/unreal/persistent-data/#1-gameinstance"><strong>GameInstance</strong></a> has, meaning that they persist both travels and disconnects.</p>

<p><strong>GameInstance</strong> subsystem exists on both server and client, though as mentioned, it isn’t replicable, i.e., the two versions aren’t necessarily in sync.</p>

<p><strong>LocalPlayer</strong> subsystem exists for each <strong>LocalPlayer</strong>. This means that it exists on server for the listen-server (host) player in case of a listen-server setup, and on client for each other client (hosted) player. In a dedicated-server setup, it won’t exist on server, but on client only for each client.</p>

<h3 id="saving--retrieving-data-1">Saving &amp; Retrieving Data<a class="header-link" href="#saving--retrieving-data-1" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Saving and retrieving data in this case isn’t any different from the way it’s done in <a href="https://wizardcell.com/unreal/persistent-data/#storing--retrieving-data"><strong>GameInstance</strong></a>, due to the fact that the mentioned subsystems have a similar lifetime to the <strong>GameInstance</strong> (they live outside <a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/Engine/Engine/UWorld/"><code class="language-plaintext highlighter-rouge">UWorlds</code></a>), making them an even better place to persist data upon traveling or disconnecting. The reason being that using <strong>GameInstance</strong> for persisting data can end up quickly bloating it, making it less optimal to handle other <strong>Objects</strong> like <strong>Sessions</strong>, <strong>SaveGames</strong>, etc.</p>

<h3 id="usage-1">Usage<a class="header-link" href="#usage-1" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Keep an optimal <strong>GameInstance</strong>.</li>
</ul>

<h4 id="gameinstance-subsystem">GameInstance Subsystem<a class="header-link" href="#gameinstance-subsystem" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>Persist world-state data between levels upon <strong>hard</strong> travels.</li>
  <li>Stash player-specific data on disconnection, and retrieve it on reconnection.</li>
</ul>

<h5 id="example-usage">Example Usage<a class="header-link" href="#example-usage" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h5>

<p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/#subsystemsexample">Stats System</a> that tracks the number of gathered resources.</p>

<h4 id="localplayer-subsystem">LocalPlayer Subsystem<a class="header-link" href="#localplayer-subsystem" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>Persist player-specific and local-player related data (such as UI, input, etc.) between levels upon <strong>hard</strong> travels.</li>
  <li>Stash player-specific and local-player related data on disconnection, and retrieve it on reconnection.</li>
</ul>

<h5 id="example-usage-1">Example Usage<a class="header-link" href="#example-usage-1" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h5>

<p>The <a href="https://docs.unrealengine.com/en-US/enhanced-input-in-unreal-engine/">Enhanced Input</a> <strong>LocalPlayer</strong> subsystem (<a href="https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Plugins/Experimental/EnhancedInput/Source/EnhancedInput/Public/EnhancedInputSubsystems.h"><code class="language-plaintext highlighter-rouge">UEnhancedInputLocalPlayerSubsystem</code></a>) which would allow you to add mapping contexts, bind input delegates, and more.</p>

<p class="notice--warning"><strong>Note:</strong> Don’t confuse <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/"><strong>Programming Subsystems</strong></a> with <a href="https://docs.unrealengine.com/en-US/online-subsystem-in-unreal-engine/"><strong>Online Subsystems</strong></a>, as they are different entities.</p>

<h2 id="3-playerstate">3. PlayerState<a class="header-link" href="#3-playerstate" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>A <strong>PlayerState</strong> is created for every player on a server (or in a standalone game). <strong>PlayerStates</strong> are relevant and replicated to all clients, and contain network game relevant information about the player, such as his name, score, ping, etc.</p>

<h3 id="where-does-this-class-exist-2">Where does this Class Exist?<a class="header-link" href="#where-does-this-class-exist-2" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>This class <strong>Actor</strong> exists on server, replicated all clients, and is always relevant (<code class="language-plaintext highlighter-rouge">bAlwaysRelevant = true</code>). Therefore, each client has knowledge of his <strong>PlayerState</strong> and all the others, at all times.</p>

<h3 id="copying-data">Copying Data<a class="header-link" href="#copying-data" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Data is copied from old instance of this <strong>Actor</strong> over to a new one upon <strong>seamless traveling</strong> or <strong>disconnecting</strong>. Both procedures take place on the server.</p>

<h3 id="usage-2">Usage<a class="header-link" href="#usage-2" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Persist player-specific data between levels upon <strong>seamless</strong> travels.</li>
  <li>Stash player-specific data on disconnection, and retrieve it on reconnection.</li>
</ul>

<h3 id="example-usage-2" class="">Example Usage<a class="header-link" href="#example-usage-2" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Let’s assume we’ve a custom <strong>PlayerState</strong> with some custom member variables:</p>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="c1">// Seamless traveled hero's non-PlayerState related data will be stored here</span>
<span class="n">USTRUCT</span><span class="p">()</span>
<span class="k">struct</span> <span class="nc">FSeamlessTraveledHeroData</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

    <span class="cm">/** Player's current selected hero to respawn as */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">TSubclassOf</span><span class="o">&lt;</span><span class="n">APawn</span><span class="o">&gt;</span> <span class="n">SelectedHero</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">AMyPlayerState</span><span class="o">:</span> <span class="k">public</span> <span class="n">APlayerState</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>
    <span class="cm">/** Player's current kill count */</span>
    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">,</span> <span class="n">Replicated</span><span class="p">)</span>
    <span class="n">int32</span> <span class="n">Kills</span><span class="p">;</span>

    <span class="cm">/** Player's current assist count */</span>
    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">,</span> <span class="n">Replicated</span><span class="p">)</span>
    <span class="n">int32</span> <span class="n">Assists</span><span class="p">;</span>

    <span class="cm">/** Player's current death count */</span>
    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">,</span> <span class="n">Replicated</span><span class="p">)</span>
    <span class="n">int32</span> <span class="n">Deaths</span><span class="p">;</span>

    <span class="cm">/** Seamless traveled player's stored data, so we reapply it when player has finished loading */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FSeamlessTraveledHeroData</span> <span class="n">SeamlessTraveledHeroData</span><span class="p">;</span>

    <span class="p">...</span>

<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<p>By default, none of these properties are preserved when the player <strong>seamless</strong> travels (or disconnects). To fix this, we need to override the following function:</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Copy properties which need to be saved in inactive PlayerState */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CopyProperties</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<p>Note that this is the same function we covered earlier that <a href="https://wizardcell.com/unreal/persistent-data/#storing-data-on-disconnection">preserves some data upon disconnection</a>. As we’ve seen earlier, only a small portion of the built in properties is preserved, and none of our custom properties is unfortunately, so we have to do it ourselves.</p>

<figure>
      <figcaption>
        <p class="figure-title">MyPlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyPlayerState</span><span class="o">::</span><span class="n">CopyProperties</span><span class="p">(</span><span class="n">APlayerState</span><span class="o">*</span> <span class="n">PlayerState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">CopyProperties</span><span class="p">(</span><span class="n">PlayerState</span><span class="p">);</span> <span class="c1">// This is called so we preserve data chosen to be preserved by default</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">AMyPlayerState</span><span class="o">*</span> <span class="n">NewPlayerState</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">AMyPlayerState</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PlayerState</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">NewPlayerState</span><span class="o">-&gt;</span><span class="n">SeamlessTraveledHeroData</span><span class="p">.</span><span class="n">SelectedHero</span> <span class="o">=</span> <span class="n">SelectedHero</span><span class="p">;</span>
        <span class="n">NewPlayerState</span><span class="o">-&gt;</span><span class="n">Kills</span> <span class="o">=</span> <span class="n">Kills</span><span class="p">;</span>
        <span class="n">NewPlayerState</span><span class="o">-&gt;</span><span class="n">Assists</span> <span class="o">=</span> <span class="n">Assists</span><span class="p">;</span>
        <span class="n">NewPlayerState</span><span class="o">-&gt;</span><span class="n">Deaths</span> <span class="o">=</span> <span class="n">Deaths</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p class="notice--warning"><strong>Note:</strong> While the old and new levels can have the same <strong>PlayerState</strong> class, the more elegant approach is to have different class for each level with a common parent <strong>PlayerState</strong> class (which they inherit from) holding all the data that gets transferred between levels.</p>

<p>Again, considering this function is used to persist data across travels and disconnects, what if there is data you don’t want to persist across travels, but you do want them to persist across disconnects?</p>

<p>That’s why <code class="language-plaintext highlighter-rouge">APlayerState::Reset()</code>, called by <code class="language-plaintext highlighter-rouge">APlayerController::SeamlessTravelFrom()</code>, is there. Properties that should be reset and not preserved across travels, should go there. This is the default implementation of that function:</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">APlayerState</span><span class="o">::</span><span class="n">Reset</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">Reset</span><span class="p">();</span>
    <span class="n">SetScore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ForceNetUpdate</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>As can be seen, <code class="language-plaintext highlighter-rouge">Score</code> property is reset, so it doesn’t persist travels, but it does persist disconnects.</p>

<p>Let’s override it so it looks like this:</p>

<figure>
      <figcaption>
        <p class="figure-title">PlayerState.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AMyPlayerState</span><span class="o">::</span><span class="n">Reset</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">Reset</span><span class="p">();</span> <span class="c1">// This is called so we reset data chosen to be reset by default, e.g., Score</span>

    <span class="n">Kills</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Assists</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Deaths</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Now, when <strong>seamless</strong> traveling: <code class="language-plaintext highlighter-rouge">Kills</code>, <code class="language-plaintext highlighter-rouge">Assists</code>, and <code class="language-plaintext highlighter-rouge">Deaths</code> will all be reset, but <code class="language-plaintext highlighter-rouge">SelectedHero</code> is kept. However, the former three properties won’t be reset when <strong>disconnecting</strong>.</p>

<p class="notice--warning"><strong>Note:</strong> <code class="language-plaintext highlighter-rouge">APlayerState::CopyProperties()</code> gets called upon <strong>seamless</strong> and <strong>hard</strong> travels. Upon traveling, the travel has to be <strong>seamless</strong> for it to be called. Upon disconnection, the travel is <strong>hard</strong> by definition, and we’ve seen earlier that it gets called (unless <a href="https://wizardcell.com/unreal/persistent-data/#the-better-more-reliable-way-to-stash-data-on-disconnection">we’ve made it not</a>).</p>

<h2 id="4-playercontroller">4. PlayerController<a class="header-link" href="#4-playercontroller" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>A <strong>PlayerController</strong> is the interface between the <strong>Pawn</strong> and the human player controlling it. The <strong>PlayerController</strong> essentially represents the human player’s will.</p>

<h3 id="where-does-this-class-exist-3">Where does this Class Exist?<a class="header-link" href="#where-does-this-class-exist-3" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>This class <strong>Actor</strong> exists on server, replicated to owning client, and only to relevant to him (<code class="language-plaintext highlighter-rouge">bOnlyRelevantToOwner = true</code>). Therefore, each client has knowledge only of his own <strong>PlayerController</strong>.</p>

<h3 id="copying-data-1">Copying Data<a class="header-link" href="#copying-data-1" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Data is copied from old instance of this <strong>Actor</strong> over to a new one upon <strong>seamless</strong> traveling, and <strong>only</strong> if <strong>either</strong> the new <strong>GameMode’s</strong> <strong>PlayerController</strong> class is <strong>different</strong> than the previous <strong>or</strong> the new <strong>GameMode’s</strong> class is a subclass of <code class="language-plaintext highlighter-rouge">AGameModeBase</code> (not <code class="language-plaintext highlighter-rouge">AGameMode</code>). If the new <strong>GameMode’s</strong> class is a <strong>subclass</strong> of <code class="language-plaintext highlighter-rouge">AGameMode</code> <strong>and</strong> its <strong>PlayerController</strong> class is the <strong>same</strong> as the previous, no data copying is done, as the same <strong>Actor</strong> persists. The data copying procedure takes place on the server.</p>

<h3 id="usage-3" class="">Usage<a class="header-link" href="#usage-3" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Persist player-specific data between levels upon <strong>seamless</strong> travels.</li>
  <li>Persist same whole <strong>PlayerController</strong> and <strong>PlayerCameraManager</strong> <strong>Actor</strong> instances between levels upon <strong>seamless</strong> travels.</li>
</ul>

<h3 id="example-usage-3">Example Usage<a class="header-link" href="#example-usage-3" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Let’s take a quick look at the documentation of the function that does the data keeping:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/**
 * Used to swap a viewport/connection's PlayerControllers when seamless traveling and the new GameMode's
 * controller class is different than the previous
 * includes network handling
 * @param OldPC - the old PC that should be discarded
 * @param NewPC - the new PC that should be used for the player
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SwapPlayerControllers</span><span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">OldPC</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">*</span> <span class="n">NewPC</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<p>Taking a quick look at this function implementation, we can tell what properties are being preserved:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AGameModeBase</span><span class="o">::</span><span class="n">SwapPlayerControllers</span><span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span><span class="n">OldPC</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">*</span> <span class="n">NewPC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsValid</span><span class="p">(</span><span class="n">OldPC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IsValid</span><span class="p">(</span><span class="n">NewPC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">OldPC</span><span class="o">-&gt;</span><span class="n">Player</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// move the Player to the new PC</span>
        <span class="n">UPlayer</span><span class="o">*</span> <span class="n">Player</span> <span class="o">=</span> <span class="n">OldPC</span><span class="o">-&gt;</span><span class="n">Player</span><span class="p">;</span>
        <span class="n">NewPC</span><span class="o">-&gt;</span><span class="n">NetPlayerIndex</span> <span class="o">=</span> <span class="n">OldPC</span><span class="o">-&gt;</span><span class="n">NetPlayerIndex</span><span class="p">;</span> <span class="c1">//@warning: critical that this is first as SetPlayer() may trigger RPCs</span>
        <span class="n">NewPC</span><span class="o">-&gt;</span><span class="n">NetConnection</span> <span class="o">=</span> <span class="n">OldPC</span><span class="o">-&gt;</span><span class="n">NetConnection</span><span class="p">;</span>
        <span class="n">NewPC</span><span class="o">-&gt;</span><span class="n">SetReplicates</span><span class="p">(</span><span class="n">OldPC</span><span class="o">-&gt;</span><span class="n">GetIsReplicated</span><span class="p">());</span>
        <span class="n">NewPC</span><span class="o">-&gt;</span><span class="n">SetPlayer</span><span class="p">(</span><span class="n">Player</span><span class="p">);</span>
        <span class="n">NewPC</span><span class="o">-&gt;</span><span class="n">CopyRemoteRoleFrom</span><span class="p">(</span><span class="n">OldPC</span><span class="p">);</span>

        <span class="n">K2_OnSwapPlayerControllers</span><span class="p">(</span><span class="n">OldPC</span><span class="p">,</span> <span class="n">NewPC</span><span class="p">);</span>

        <span class="p">...</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Notice that the native version function above calls the following <strong>Blueprint</strong> version:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Called when a PlayerController is swapped to a new one during seamless travel */</span>
<span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintImplementableEvent</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="n">Game</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">DisplayName</span><span class="o">=</span><span class="s">"OnSwapPlayerControllers"</span><span class="p">,</span> <span class="n">ScriptName</span><span class="o">=</span><span class="s">"OnSwapPlayerControllers"</span><span class="p">))</span>
<span class="kt">void</span> <span class="nf">K2_OnSwapPlayerControllers</span><span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">OldPC</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">*</span> <span class="n">NewPC</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<p class="notice--warning"><strong>Note:</strong> The functions above have to be overridden in the <strong>GameMode</strong> class of the destination level.</p>

<h2 id="5-getseamlesstravelactorlist">5. GetSeamlessTravelActorList<a class="header-link" href="#5-getseamlesstravelactorlist" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>There are two versions of this function, in two different classes: <strong>GameMode</strong> and <strong>PlayerController</strong>.
Let’s look at the former’s documentation:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/**
 * called on server during seamless level transitions to get the list of Actors that should be moved into the new level
 * PlayerControllers, Role &lt; ROLE_Authority Actors, and any non-Actors that are inside an Actor that is in the list
 * (i.e. Object.Outer == Actor in the list)
 * are all automatically moved regardless of whether they're included here
 * only dynamic actors in the PersistentLevel may be moved (this includes all actors spawned during gameplay)
 * this is called for both parts of the transition because actors might change while in the middle (e.g. players might join or leave the game)
 * @see also PlayerController::GetSeamlessTravelActorList() (the function that's called on clients)
 * @param bToTransition true if we are going from old level to transition map, false if we are going from transition map to new level
 * @param ActorList (out) list of actors to maintain
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">);</span>
</code></pre></div></div>


  </div></figure>

<p>We have already <a href="https://wizardcell.com/unreal/persistent-data/#persisting-data-across-seamless-travel">seen</a> that it’s used to persist <strong>Objects</strong> to transition and destination maps, as it will be called twice, once when the transition map is reached, and again when the destination map is reached. It is guaranteed that <strong>Objects</strong> won’t be garbage collected during the whole process.</p>

<h3 id="saving--retrieving-data-2" class="">Saving &amp; Retrieving Data<a class="header-link" href="#saving--retrieving-data-2" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>What makes this option special, is that you don’t need a third-party <strong>Object</strong> to save the data for the <strong>Actor</strong> in question. You neither even need to copy any data (as long as you don’t destroy the <strong>Actor</strong> manually), as the <strong>Actor</strong> itself persists with little to no effort. However, there is a good chance the <strong>Object</strong> which has a pointer to our persistent spawned <strong>Actor</strong> isn’t persistent, i.e. is going to be destroyed and garbage collected, resulting in a loss of the direct reference to our persistent <strong>Actor</strong>. Luckily, we do either <code class="language-plaintext highlighter-rouge">TActorRange&lt;PersistentActorClass&gt;</code> in native code, or <code class="language-plaintext highlighter-rouge">GetAllActorsOfClass</code> in Blueprint, to find our persistent <strong>Actor</strong> again, and reestablish the linkage. It doesn’t matter how early we try to find it in the new level, it’s going to be there, making it ideal for initialization order too.</p>

<h3 id="usage-4">Usage<a class="header-link" href="#usage-4" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Truly persist <strong>Objects</strong> with little to no effort.</li>
  <li>Great for initialization order.</li>
</ul>

<h4 id="agamemodebase-getseamlesstravelactorlist">AGameModeBase:: GetSeamlessTravelActorList<a class="header-link" href="#agamemodebase-getseamlesstravelactorlist" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>Persist server-side world-state <strong>Objects</strong> between levels upon <strong>seamless</strong> travels.</li>
</ul>

<h4 id="aplayercontroller-getseamlesstravelactorlist">APlayerController:: GetSeamlessTravelActorList<a class="header-link" href="#aplayercontroller-getseamlesstravelactorlist" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<ul>
  <li>Persist local-player (usually client-side) related <strong>Objects</strong> between levels upon <strong>seamless</strong> travels.</li>
</ul>

<p class="notice--warning"><strong>Note:</strong> The <strong>PlayerController</strong> function version can be called server-side as we’ve <a href="https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-destination-map">seen</a> earlier, in case of a listen-server player.</p>

<h3 id="example-usage-4" class="">Example Usage<a class="header-link" href="#example-usage-4" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Say we want to store information about each team playing the match. The <strong>Actor</strong> that generally stores match state info is <strong>GameState</strong>. However, what if we want this info to persist between levels, so we can reward players based on that info before a new match starts. Also what if the teams were imbalanced and we want our balancing system to automatically balance them before a new match starts.</p>

<p>We already mentioned <a href="https://wizardcell.com/unreal/persistent-data/#should-they-be-kept-to-destination-map">why</a> we shouldn’t persist <strong>GameState</strong> to destination map. Instead, we will make a similar replicated, always relevant, singleton <strong>Actor</strong>:</p>

<figure>
      <figcaption>
        <p class="figure-title">TeamSetup.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">USTRUCT</span><span class="p">()</span>
<span class="k">struct</span> <span class="nc">FTeamInfo</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">int32</span> <span class="n">TeamId</span><span class="p">;</span>

    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FText</span> <span class="n">Name</span><span class="p">;</span>
    
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">int32</span> <span class="n">Score</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">AddScore</span><span class="p">(</span><span class="n">int32</span> <span class="n">InScore</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Score</span> <span class="o">+=</span> <span class="n">InScore</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ATeamSetup</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AInfo</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>

    <span class="n">ATeamSetup</span><span class="p">(</span><span class="k">const</span> <span class="n">FObjectInitializer</span><span class="o">&amp;</span> <span class="n">ObjectInitializer</span> <span class="o">=</span> <span class="n">FObjectInitializer</span><span class="o">::</span><span class="n">Get</span><span class="p">());</span>

    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">)</span>
    <span class="n">TArray</span><span class="o">&lt;</span><span class="n">FTeamInfo</span><span class="o">&gt;</span> <span class="n">Teams</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">TeamSetup.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">ATeamSetup</span><span class="o">::</span><span class="n">ATeamSetup</span><span class="p">(</span><span class="k">const</span> <span class="n">FObjectInitializer</span><span class="o">&amp;</span> <span class="n">ObjectInitializer</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Super</span><span class="p">(</span><span class="n">ObjectInitializer</span><span class="p">.</span><span class="n">DoNotCreateDefaultSubobject</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Sprite"</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">bReplicates</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">bAlwaysRelevant</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>We will end up having two <strong>GameModes</strong>: <code class="language-plaintext highlighter-rouge">ALobbyGameMode</code> and <code class="language-plaintext highlighter-rouge">ACombatGameMode</code>. A good practice is to subclass both classes to <code class="language-plaintext highlighter-rouge">ABaseGameMode</code>, which has shared stuff there, including what needs to persist. In our case we will make <code class="language-plaintext highlighter-rouge">ALobbyGameMode</code> spawn it, and cache a pointer to it:</p>

<figure>
      <figcaption>
        <p class="figure-title">BaseGameMode.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Used to setup teams and replicate teams related info to all clients */</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">ATeamSetup</span><span class="o">&gt;</span> <span class="n">TeamSetup</span><span class="p">;</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">BaseGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">ABaseGameMode</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="n">bToTransition</span><span class="p">,</span> <span class="n">ActorList</span><span class="p">);</span>

    <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TeamSetup</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">BaseGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">ABaseGameMode</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bToTransition</span><span class="p">,</span> <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">*&gt;&amp;</span> <span class="n">ActorList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">GetSeamlessTravelActorList</span><span class="p">(</span><span class="n">bToTransition</span><span class="p">,</span> <span class="n">ActorList</span><span class="p">);</span>

    <span class="n">ActorList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TeamSetup</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">LobbyGameMode.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ALobbyGameMode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AGameMode</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">PreInitializeComponents</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">LobbyGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">ALobbyGameMode</span><span class="o">::</span><span class="n">PreInitializeComponents</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">PreInitializeComponents</span><span class="p">();</span>

    <span class="n">FActorSpawnParameters</span> <span class="n">SpawnInfo</span><span class="p">;</span>
    <span class="n">SpawnInfo</span><span class="p">.</span><span class="n">Instigator</span> <span class="o">=</span> <span class="n">GetInstigator</span><span class="p">();</span>
    <span class="n">SpawnInfo</span><span class="p">.</span><span class="n">ObjectFlags</span> <span class="o">|=</span> <span class="n">RF_Transient</span><span class="p">;</span>  <span class="c1">// We never want to save team setups into the map</span>

    <span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span> <span class="o">=</span> <span class="n">GetWorld</span><span class="p">();</span>
    <span class="n">TeamSetup</span> <span class="o">=</span> <span class="n">World</span><span class="o">-&gt;</span><span class="n">SpawnActor</span><span class="o">&lt;</span><span class="n">ATeamSetup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ATeamSetup</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span> <span class="n">SpawnInfo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>In order for our <code class="language-plaintext highlighter-rouge">TeamSetup</code> <strong>Actor</strong> to be easily accessible by all, we will pass it to <code class="language-plaintext highlighter-rouge">ACombatGameState</code>, which is replicated and always relevant to all clients. As we <a href="https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data-2">noted</a> earlier, <code class="language-plaintext highlighter-rouge">ALobbyGameMode</code> has a pointer to the <strong>Actor</strong> we’re persisting, though it <a href="https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-transition-map-only">doesn’t persist to the destination map</a>, which results in a loss of the direct reference to <code class="language-plaintext highlighter-rouge">TeamSetup</code> <strong>Actor</strong>. To reestablish the linkage, we’ll have to find it again:</p>

<figure>
      <figcaption>
        <p class="figure-title">CombatGameMode.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ACombatGameMode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ABaseGameMode</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="nl">public:</span>
    <span class="cm">/**
     * Initialize the GameState actor with default settings
     * called during PreInitializeComponents() of the GameMode after a GameState has been spawned
     * as well as during Reset()
     */</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">InitGameState</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<figure>
      <figcaption>
        <p class="figure-title">CombatGameMode.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">ACombatGameMode</span><span class="o">::</span><span class="n">InitGameState</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">InitGameState</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">ATeamSetup</span><span class="o">*</span> <span class="n">MyTeamSetup</span> <span class="o">:</span> <span class="n">TActorRange</span><span class="o">&lt;</span><span class="n">ATeamSetup</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetWorld</span><span class="p">()))</span>
    <span class="p">{</span>
        <span class="n">TeamSetup</span> <span class="o">=</span> <span class="n">MyTeamSetup</span><span class="p">;</span> <span class="c1">// reestablish the linkage</span>

        <span class="k">if</span><span class="p">(</span><span class="n">ACombatGameState</span><span class="o">*</span> <span class="n">GS</span> <span class="o">=</span> <span class="n">GetGameState</span><span class="o">&lt;</span><span class="n">ABTGameState</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">GS</span><span class="o">-&gt;</span><span class="n">TeamSetup</span> <span class="o">=</span> <span class="n">TeamSetup</span><span class="p">;</span> <span class="c1">// cache it in GameState so it's easily accessible client-side</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Note that we are finding the <strong>Actor</strong> before the new <strong>GameMode</strong> has <a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/">instantiated</a>, so it can be found way before <code class="language-plaintext highlighter-rouge">BeginPlay()</code> is called, making it great for initialization order, so it’s just there, no matter how early we try to find it.</p>

<h3 id="persistent-hud-example">Persistent HUD Example<a class="header-link" href="#persistent-hud-example" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Coming Soon<img class="emoji" title=":tm:" alt=":tm:" src="https://github.githubassets.com/images/icons/emoji/unicode/2122.png" height="20" width="20"></p>

<h2 id="6-savegame">6. SaveGame<a class="header-link" href="#6-savegame" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>This class acts as a base class for a save game <strong>Object</strong> that can be used to save state about the game.</p>

<h3 id="where-does-this-class-exist-4">Where does this Class Exist?<a class="header-link" href="#where-does-this-class-exist-4" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>This class is locally created, i.e., created wherever you save your data. Therefore, it can exist on both server and client, though it has no support for any kind of replication.</p>

<h3 id="saving--retrieving-data-3" class="">Saving &amp; Retrieving Data<a class="header-link" href="#saving--retrieving-data-3" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>A <strong>SaveGame</strong> <strong>Object</strong>/file is saved directly to your disk, making it a great class to save data that should persist a game shutdown (which marks the end of <strong>GameInstance’s</strong> lifetime and any subsystems that have a similar lifetime). Depending on your game size, you might have multiple <strong>SaveGame</strong> <strong>Objects</strong>, so it becomes tricky to keep track of them, and if not managed properly, it becomes quite a mess. Therefore, the <strong>GameInstance</strong> can come in handy as a manager for all of our <strong>SaveGame</strong> <strong>Objects</strong>. If you feel that can bloat your <strong>GameInstance</strong> class you can opt for a <strong>GameInstance</strong> subsystem. Both options are great, due to the fact that they are alive as long as the game application is running, and they are easily accessible from almost anywhere. Data can be saved upon traveling or disconnecting, and retrieved/loaded when travel is finished or on reconnection.</p>

<h3 id="usage-5" class="">Usage<a class="header-link" href="#usage-5" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Save either player-specific or world-state data that should persist a game exit.</li>
  <li>Save game-user settings (though usually they are saved in <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/GameFramework/UGameUserSettings/">specialized file configs</a>.</li>
</ul>

<h3 id="example-usage-5" class="">Example Usage<a class="header-link" href="#example-usage-5" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>There is a plethora of examples I stumbled across, though here are the ones I suggest:</p>

<ul>
  <li><a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/SaveGame/">Saving and Loading Your Game (Official Docs)</a></li>
  <li><a href="https://www.tomlooman.com/unreal-engine-cpp-save-system/">Unreal Engine C++ Save System (Tom Looman Tutorial)</a></li>
  <li><a href="https://github.com/sinbad/SPUD">SPUD: Steve’s Persistent Unreal Data library (Complete Save System Plugin)</a></li>
</ul>

<h2 id="7-game-options-string" class="">7. Game Options String<a class="header-link" href="#7-game-options-string" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>While the previous methods revolved around <strong>Objects</strong>, this one isn’t of such kind.</p>

<p>We have already come to mention the options string, which is part of the so called <strong>URL</strong>, in the context of <a href="https://wizardcell.com/unreal/persistent-data/#travel-types"><strong>Travel Types</strong></a>.
You can already tell we can make good use of it, to persist data upon traveling.</p>

<p class="notice--primary"><strong>Remember:</strong> Loading into the game is a travel, specifically a hard one.</p>

<h3 id="url-structure" class="active">URL Structure<a class="header-link" href="#url-structure" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>Here are the <strong>parameters</strong> a <strong>URL</strong> consists of:</p>

<figure>
      <figcaption>
        <p class="figure-title">EngineBaseTypes.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="c1">// URL structure.</span>
<span class="n">USTRUCT</span><span class="p">()</span>
<span class="k">struct</span> <span class="nc">ENGINE_API</span> <span class="n">FURL</span>
<span class="p">{</span>
    <span class="n">GENERATED_USTRUCT_BODY</span><span class="p">()</span>

    <span class="c1">// Protocol, i.e. "unreal" or "http".</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FString</span> <span class="n">Protocol</span><span class="p">;</span>

    <span class="c1">// Optional hostname, i.e. "204.157.115.40" or "unreal.epicgames.com", blank if local.</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FString</span> <span class="n">Host</span><span class="p">;</span>

    <span class="c1">// Optional host port.</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">int32</span> <span class="n">Port</span><span class="p">;</span>

    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">int32</span> <span class="n">Valid</span><span class="p">;</span>

    <span class="c1">// Map name, i.e. "SkyCity", default is "Entry".</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FString</span> <span class="n">Map</span><span class="p">;</span>

    <span class="c1">// Optional place to download Map if client does not possess it</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FString</span> <span class="n">RedirectURL</span><span class="p">;</span>

    <span class="c1">// Options.</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">TArray</span><span class="o">&lt;</span><span class="n">FString</span><span class="o">&gt;</span> <span class="n">Op</span><span class="p">;</span>

    <span class="c1">// Portal to enter through, default is "".</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="n">FString</span> <span class="n">Portal</span><span class="p">;</span>

    <span class="c1">// Statics.</span>
    <span class="k">static</span> <span class="n">FUrlConfig</span> <span class="n">UrlConfig</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">bDefaultsInitialized</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<p><strong>URLs</strong> can be passed to the executable to force the game to load a specific map upon startup. These can also be used in conjunction with the SERVER or EDITOR modes to run the editor or a server with a specific map. Passing a <strong>URL</strong> is optional, but must immediately follow the executable name or any mode switch if one is present.</p>

<p>A <strong>URL</strong> consists of <strong>two parts</strong>: a <strong>map name or server IP address</strong> and a series of <strong>optional additional parameters</strong>. A map name (<code class="language-plaintext highlighter-rouge">FURL.Map</code>) can be any map located within the Maps directory. The inclusion of a file extension (<code class="language-plaintext highlighter-rouge">.umap</code>) here is optional. To load a map not found in the Maps directory, an absolute path or a relative path from the Maps directory can be used. In this case, the inclusion of the file extension is mandatory. The server IP address (<code class="language-plaintext highlighter-rouge">FURL.Host</code>) is a standard four-part IP address consisting of four values between 0 and 255 separated by periods. The additional options (<code class="language-plaintext highlighter-rouge">FURL.Op</code>) are specified by appending them to the map name or server IP address. Each option is prefaced by a <code class="language-plaintext highlighter-rouge">?</code> (which acts as a separator), and can be set a value with <code class="language-plaintext highlighter-rouge">=</code>, i.e., in the format of: <code class="language-plaintext highlighter-rouge">?option1=value1?option2=value2</code>. Starting an option with <code class="language-plaintext highlighter-rouge">-</code> will remove that option from the cached <strong>URL</strong> options.</p>

<p class="notice--warning"><strong>Note:</strong> Any added meaningless characters (leading blanks, doubled <code class="language-plaintext highlighter-rouge">?</code>) are usually skipped. Other characters are not allowed (double slashes/backslashes, in any combination, nor <code class="language-plaintext highlighter-rouge">\?</code>) resulting in an invalid <strong>URL</strong> (i.e. <code class="language-plaintext highlighter-rouge">FURL.Valid = 0</code>). Therefore, you shouldn’t try to fail it, but instead put only what’s needed.</p>

<h3 id="url-built-in-options" class="">URL Built-in Options<a class="header-link" href="#url-built-in-options" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>There are two cached <strong>URLs</strong> for every connection:</p>

<ol>
  <li>
<strong>World URL</strong> (<code class="language-plaintext highlighter-rouge">UWorld.URL</code>): Cached loading world URL.</li>
  <li>
<strong>Demo URL</strong> (<code class="language-plaintext highlighter-rouge">FReplayHelper.DemoURL</code>): Cached replay URL.</li>
</ol>

<p>The following table has <em>all</em> the built-in options:</p>

<table class="table">
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
      <th style="text-align: center">World URL Option?</th>
      <th style="text-align: center">Demo URL Option?</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Game</strong></td>
      <td>Alias name for GameMode class to use.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>Overrides default.<br>Alias name is set up in <code class="language-plaintext highlighter-rouge">Project Settings-&gt;Maps &amp; Modes-&gt;Default Modes-&gt;Advanced-&gt;Game Mode Class Aliases</code>.</td>
    </tr>
    <tr>
      <td><strong>Load</strong></td>
      <td>If set, loaded world URL won’t be cached.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Name</strong></td>
      <td>Player/bot name to use.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>Has a limit length of 20 characters.</td>
    </tr>
    <tr>
      <td><strong>MaxPlayers</strong></td>
      <td>Maximum number of players allowed by server.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>MaxSpectators</strong></td>
      <td>Maximum number of spectators allowed by server.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>SplitscreenCount</strong></td>
      <td>Number of split-screen players to allow from one connection.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Listen</strong></td>
      <td>Specifies the server as a listen server.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>bIsLanMatch</strong></td>
      <td>Sets whether the multiplayer game is on the local network.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>bPassthrough</strong></td>
      <td>Sets whether this net connection is passthrough to IpConnection.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>Uses passthrough sockets.</td>
    </tr>
    <tr>
      <td><strong>bUseIPSockets</strong></td>
      <td>Sets whether to use IP sockets.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>LAN</strong></td>
      <td>Used to set lan-related settings.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>Retrieves <code class="language-plaintext highlighter-rouge">ConfiguredLanSpeed</code>.</td>
    </tr>
    <tr>
      <td><strong>bIsFromInvite</strong></td>
      <td>Specifies that the player joining was invited.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>SpectatorOnly</strong></td>
      <td>Starts the game in spectator mode.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>SkipSpawnSpectatorController</strong></td>
      <td>Skips spawning the demo spectator.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>DemoRec</strong></td>
      <td>Demo recording name to use.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>DemoFriendlyName</strong></td>
      <td>Description of replay, preferably human readable.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>RecordMapChanges</strong></td>
      <td>Sets whether demo net driver records map changes/travels.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><a href="https://docs.unrealengine.com/en-US/TestingAndOptimization/ReplaySystem/Streamers/#demonetdriverfeatures"><strong>ReplayStreamerOverride</strong></a></td>
      <td>Overrides the default <code class="language-plaintext highlighter-rouge">FReplayHelper.ReplayStreamer</code>.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>Value: <code class="language-plaintext highlighter-rouge">True/Yes/On</code> vs. <code class="language-plaintext highlighter-rouge">False/No/Off</code>.</td>
    </tr>
    <tr>
      <td><strong>ReplayStreamerDemoPath</strong></td>
      <td>Changes the base directory where Demos are stored.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>Value: <code class="language-plaintext highlighter-rouge">True/Yes/On</code> vs. <code class="language-plaintext highlighter-rouge">False/No/Off</code>.</td>
    </tr>
    <tr>
      <td><strong>SkipToLevelIndex</strong></td>
      <td>Causes current replay to skip to the level with the specified index.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>From the used list of levels.</td>
    </tr>
    <tr>
      <td><strong>AsyncLoadWorldOverride</strong></td>
      <td>Overrides the default async world loading <code class="language-plaintext highlighter-rouge">CVarDemoAsyncLoadWorld</code> value.</td>
      <td style="text-align: center">&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td>Value: <code class="language-plaintext highlighter-rouge">True/Yes/On</code> vs. <code class="language-plaintext highlighter-rouge">False/No/Off</code>.</td>
    </tr>
    <tr>
      <td><strong>LevelPrefixOverride</strong></td>
      <td>Sets the level ID/PIE instance ID for this net driver to use.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>AuthTicket</strong></td>
      <td>Token to use for verification.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>EncryptionToken</strong></td>
      <td>Token to make the server start the process of enabling encryption for the connection.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>More info <a href="https://forums.unrealengine.com/t/how-to-enable-encryption-using-packet-handler-components/264938">here</a>.</td>
    </tr>
    <tr>
      <td><strong>NoTimeouts</strong></td>
      <td>Ignore timeouts completely. Should be used only in development.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Failed</strong></td>
      <td>Travel failure occurred.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Closed</strong></td>
      <td>Connection to server closed.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Restart</strong></td>
      <td>Reuse the URL from the last time we traveled.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>Quiet</strong></td>
      <td>&nbsp;</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>SeamlessTravel</strong></td>
      <td>Sets the <code class="language-plaintext highlighter-rouge">ServerTravel</code> to be seamless.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>Overrides default (coming soon<img class="emoji" title=":tm:" alt=":tm:" src="https://github.githubassets.com/images/icons/emoji/unicode/2122.png" height="20" width="20">).</td>
    </tr>
    <tr>
      <td><strong>NoSeamlessTravel</strong></td>
      <td>Sets the <code class="language-plaintext highlighter-rouge">ServerTravel</code> to be non-seamless.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>Overrides default (coming soon<img class="emoji" title=":tm:" alt=":tm:" src="https://github.githubassets.com/images/icons/emoji/unicode/2122.png" height="20" width="20">).</td>
    </tr>
    <tr>
      <td><strong>Mutator</strong></td>
      <td>Loads the package for the specified mutator.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>More info <a href="https://unreal.fandom.com/wiki/Mutator">here</a> and <a href="https://nerivec.github.io/old-ue4-wiki/pages/c-mutator-tutorial.html">here</a>.</td>
    </tr>
    <tr>
      <td><strong>BugLoc</strong></td>
      <td>Moves the player to the specified location.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>e.g. <code class="language-plaintext highlighter-rouge">BugLoc=(X=1798.8569,Y=475.9513,Z=-8.8500)</code>
</td>
    </tr>
    <tr>
      <td><strong>BugRot</strong></td>
      <td>Sets the player to the specified rotation.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>e.g. <code class="language-plaintext highlighter-rouge">BugRot=(Pitch=-1978,Yaw=-7197,Roll=0)</code>
</td>
    </tr>
    <tr>
      <td><strong>CauseEvent</strong></td>
      <td>Issue cause event after first tick to provide a chance for the game to spawn the player and such.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>InitialConnectTimeout</strong></td>
      <td>Overrides <code class="language-plaintext highlighter-rouge">NetDriver.InitialConnectTimeout</code>.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><strong>ConnectTimeout</strong></td>
      <td>Overrides <code class="language-plaintext highlighter-rouge">NetDriver.ConnectTimeout</code>.</td>
      <td style="text-align: center"><img class="emoji" title=":heavy_check_mark:" alt=":heavy_check_mark:" src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png" height="20" width="20"></td>
      <td style="text-align: center">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

<p class="notice--warning"><strong>Note:</strong> Like console commands, options are not case-sensitive.</p>

<h3 id="passing--parsing-data" class="">Passing &amp; Parsing Data<a class="header-link" href="#passing--parsing-data" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>No matter what function you choose to travel with, you should be able to pass a <strong>URL</strong> as parameter. In native code the parameter is referred to as: <code class="language-plaintext highlighter-rouge">URL</code>/<code class="language-plaintext highlighter-rouge">InURL</code>/<code class="language-plaintext highlighter-rouge">Cmd</code>.</p>

<p>In Blueprints there are two main functions that drive traveling:</p>

<ul>
  <li>
<strong>OpenLevel</strong> :</li>
</ul>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/open-level.png" alt="OpenLevel" class="align-center"></p>

<p>The native function is <code class="language-plaintext highlighter-rouge">UGameplayStatics::OpenLevel()</code>. Here’s how it builds the <strong>URL</strong> :</p>

<figure>
      <figcaption>
        <p class="figure-title">GameplayStatics.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">UGameplayStatics</span><span class="o">::</span><span class="n">OpenLevel</span><span class="p">(</span><span class="k">const</span> <span class="n">UObject</span><span class="o">*</span> <span class="n">WorldContextObject</span><span class="p">,</span> <span class="n">FName</span> <span class="n">LevelName</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bAbsolute</span><span class="p">,</span> <span class="n">FString</span> <span class="n">Options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">const</span> <span class="n">ETravelType</span> <span class="n">TravelType</span> <span class="o">=</span> <span class="p">(</span><span class="n">bAbsolute</span> <span class="o">?</span> <span class="n">TRAVEL_Absolute</span> <span class="o">:</span> <span class="n">TRAVEL_Relative</span><span class="p">);</span>
    <span class="n">FWorldContext</span> <span class="o">&amp;</span><span class="n">WorldContext</span> <span class="o">=</span> <span class="n">GEngine</span><span class="o">-&gt;</span><span class="n">GetWorldContextFromWorldChecked</span><span class="p">(</span><span class="n">World</span><span class="p">);</span>
    <span class="n">FString</span> <span class="n">Cmd</span> <span class="o">=</span> <span class="n">LevelName</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Options</span><span class="p">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Cmd</span> <span class="o">+=</span> <span class="n">FString</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"?"</span><span class="p">))</span> <span class="o">+</span> <span class="n">Options</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FURL</span> <span class="n">TestURL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">WorldContext</span><span class="p">.</span><span class="n">LastURL</span><span class="p">,</span> <span class="o">*</span><span class="n">Cmd</span><span class="p">,</span> <span class="n">TravelType</span><span class="p">);</span>
        
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Now we conclude that <code class="language-plaintext highlighter-rouge">Options</code> parameter corresponds to <code class="language-plaintext highlighter-rouge">FURL.Op</code>. Also you can see there is no need to preface the first option with <code class="language-plaintext highlighter-rouge">?</code> as it’s already done for you.</p>

<p>As noted earlier, <code class="language-plaintext highlighter-rouge">bAbsolute = true</code> by default, which resets the <code class="language-plaintext highlighter-rouge">Options</code> string we used to have, otherwise it’s carried over from previous level, i.e., the <code class="language-plaintext highlighter-rouge">Options</code> string we are passing now is appended to it (more on <a href="https://wizardcell.com/unreal/persistent-data/#the-enigmas">this enigma</a> below).</p>

<ul>
  <li>
<strong>ExecuteConsoleCommand</strong> :</li>
</ul>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/execute-console-command.png" alt="ExecuteConsoleCommand" class="align-center"></p>

<p>For traveling, this is how <code class="language-plaintext highlighter-rouge">Command</code> usually looks like: <code class="language-plaintext highlighter-rouge">&lt;TravelCommand&gt; &lt;MapName&gt;&lt;OptionsString&gt;</code>.<br>
So for example: <code class="language-plaintext highlighter-rouge">ServerTravel MyMap?Listen?Game=MyGameMode</code>.</p>

<p class="notice--warning"><strong>Note:</strong> <code class="language-plaintext highlighter-rouge">OptionsString</code> is appended to <code class="language-plaintext highlighter-rouge">MapName</code>. It starts with the character <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>But wait, is it really sane to have to hard-code the <code class="language-plaintext highlighter-rouge">Options</code> string every time we do a travel? Clearly not. Thanks to <a href="https://cedric-neukirchen.net/">Cedric</a> for drawing my attention to the following function:</p>

<figure>
      <figcaption>
        <p class="figure-title">LocalPlayer.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** 
 * Retrieves any game-specific login options for this player
 * if this function returns a non-empty string, the returned option or options be added
 * passed in to the level loading and connection code.  Options are in URL format,
 * key=value, with multiple options concatenated together with an &amp; between each key/value pair
 * 
 * @return URL Option or options for this game, Empty string otherwise
 */</span>
<span class="k">virtual</span> <span class="n">FString</span> <span class="nf">GetGameLoginOptions</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">""</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>This function lets you centralize the hard-coded <code class="language-plaintext highlighter-rouge">Options</code> string, such that all you need to do to retrieve the <code class="language-plaintext highlighter-rouge">Options</code> string pending a travel, is to call it. Note that you have to add your own <strong>LocalPlayer</strong> class, and set it inside <code class="language-plaintext highlighter-rouge">Project Settings-&gt;General Settings-&gt;Default Classes</code>, and then your are good to go at overriding the function.</p>

<p>To parse the options string you have a <a href="https://docs.unrealengine.com/en-US/BlueprintAPI/GameOptions/">few functions</a> at your disposal.</p>

<p class="notice--primary"><strong>Tip:</strong> See the previously <a href="https://wizardcell.com/unreal/persistent-data/#native-travel-drivers">mentioned</a>, native functions, to do it in natively.</p>

<h3 id="the-enigmas" class="">The Enigmas<a class="header-link" href="#the-enigmas" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>There were two enigmas I faced along the way:</p>

<p><strong>(1)</strong> You might have noticed that the <strong>GameMode</strong> caches the options string:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/** Save options string and parse it when needed */</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadOnly</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="n">GameMode</span><span class="p">)</span>
<span class="n">FString</span> <span class="n">OptionsString</span><span class="p">;</span>
</code></pre></div></div>


  </div></figure>

<p>First question that came to my mind is: “Considering the <strong>GameMode</strong> class exists only on server, how is this string cached per connection?”<br></p>

<p>When the map loads for the first time, the following function is called:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">AGameModeBase</span><span class="o">::</span><span class="n">InitGame</span><span class="p">(</span><span class="k">const</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">MapName</span><span class="p">,</span> <span class="k">const</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">Options</span><span class="p">,</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">ErrorMessage</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// Save Options for future use</span>
    <span class="n">OptionsString</span> <span class="o">=</span> <span class="n">Options</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>Considering this is the only place where <code class="language-plaintext highlighter-rouge">AGameModeBase.OptionsString</code> is cached, we conclude:</p>

<ul>
  <li>In case of a <strong>listen-server</strong> setup: The <code class="language-plaintext highlighter-rouge">OptionsString</code> belongs to the host player.</li>
</ul>

<p>For example, say a player is hosting a map, i.e., loading as listen-server. He might want to call the following function with the set parameters:</p>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/open-level-listen.png" alt="OpenLevelListen" class="align-center"></p>

<p>Considering he’s the one loading the map for the first time, then <code class="language-plaintext highlighter-rouge">OptionsString</code> equals the passed parameter <code class="language-plaintext highlighter-rouge">Options</code>. Other players joining the map won’t affect it. Then where is their options string cached?</p>

<p>The answer lies in the <a href="https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess">connection process</a>. Any client attempting to join the server will call <code class="language-plaintext highlighter-rouge">AGameModeBase::PreLogin(const FString&amp; Options, ...)</code>, which has the option string passed as parameter. One of the further down called functions is the following:</p>

<figure>
      <figcaption>
        <p class="figure-title">GameModeBase.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="cm">/**
 * Customize incoming player based on URL options
 *
 * @param NewPlayerController player logging in
 * @param UniqueId unique id for this player
 * @param Options URL options that came at login
 *
 */</span>
<span class="k">virtual</span> <span class="n">FString</span> <span class="nf">InitNewPlayer</span><span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">NewPlayerController</span><span class="p">,</span> <span class="k">const</span> <span class="n">FUniqueNetIdRepl</span><span class="o">&amp;</span> <span class="n">UniqueId</span><span class="p">,</span> <span class="k">const</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">Options</span><span class="p">,</span> <span class="k">const</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">Portal</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">""</span><span class="p">));</span>
</code></pre></div></div>


  </div></figure>

<p>By looking at its implementation, you will understand that for clients, the options string is parsed but not cached. I will leave it you to see how it pareses the <strong>URL</strong> options.</p>

<p class="notice--warning"><strong>Note:</strong> <code class="language-plaintext highlighter-rouge">AGameModeBase::InitNewPlayer()</code> and the login functions (<code class="language-plaintext highlighter-rouge">AGameModeBase::PreLogin()</code>/<code class="language-plaintext highlighter-rouge">AGameModeBase::Login()</code>) called before it, are called only when <strong>hard</strong> traveling. <code class="language-plaintext highlighter-rouge">AGameModeBase::PreLogin()</code> is called for client connections attempting to join the server. <code class="language-plaintext highlighter-rouge">AGameModeBase::Login()</code> is called for each accepted client connection, including the listen-server connection in case such one exists.</p>

<ul>
  <li>In case of a <strong>dedicated-server</strong> setup: The options string belongs to the server. For clients it varies, depending on what travel command they traveled with. For example <code class="language-plaintext highlighter-rouge">ServerTravel</code>, travels all clients with the same options string as the server. If you want the ability to pass a different options string you need use either <code class="language-plaintext highlighter-rouge">Travel</code> or <code class="language-plaintext highlighter-rouge">Open</code> commands.<br><br>
</li>
</ul>

<p><strong>(2)</strong> As we said earlier a few times now, that depending on the <a href="https://wizardcell.com/unreal/persistent-data/#travel-types">travel type</a>, the options string might get reset. What does that really mean?</p>

<p>Let’s look at the example from before: A player is hosting a map, i.e., loading as listen-server. He might want to call the following function with the set parameters:</p>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/open-level-listen.png" alt="OpenLevelListen" class="align-center"></p>

<p>As you see, <code class="language-plaintext highlighter-rouge">bAbsolute = true</code>, meaning the travel type is <code class="language-plaintext highlighter-rouge">TRAVEL_Absolute</code>, and we already said that means that the whole last <strong>URL</strong> is ignored, including the options string. In our case, does that mean the <code class="language-plaintext highlighter-rouge">Options</code> string parameter is ignored?</p>

<p>The answer is clearly no, <code class="language-plaintext highlighter-rouge">Options</code> isn’t ignored. The reason is that the <strong>last URL</strong> is the one ignored, and <code class="language-plaintext highlighter-rouge">Options</code> is part of the <strong>current one</strong> we are traveling with. Also it doesn’t make sense for it to be ignored/reset, cause otherwise we won’t be able to host a map at all.</p>

<p>To get the full picture you will have to look at the following struct:</p>

<figure>
      <figcaption>
        <p class="figure-title">Engine.h</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="n">USTRUCT</span><span class="p">()</span>
<span class="k">struct</span> <span class="nc">FWorldContext</span>
<span class="p">{</span>
    <span class="n">GENERATED_USTRUCT_BODY</span><span class="p">()</span>

    <span class="p">...</span>

    <span class="cm">/** URL to travel to for pending client connect */</span>
    <span class="n">FString</span> <span class="n">TravelURL</span><span class="p">;</span>

    <span class="cm">/** TravelType for pending client connects */</span>
    <span class="n">uint8</span> <span class="n">TravelType</span><span class="p">;</span>

    <span class="cm">/** URL the last time we traveled */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="k">struct</span> <span class="nc">FURL</span> <span class="n">LastURL</span><span class="p">;</span>

    <span class="cm">/** last server we connected to (for "reconnect" command) */</span>
    <span class="n">UPROPERTY</span><span class="p">()</span>
    <span class="k">struct</span> <span class="nc">FURL</span> <span class="n">LastRemoteURL</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>


  </div></figure>

<p>As can be seen, <code class="language-plaintext highlighter-rouge">FWorldContext.LasURL</code> is the last <strong>URL</strong>, while <code class="language-plaintext highlighter-rouge">FWorldContext.TravelURL</code> is the current one (the one the client is traveling with). Documentation about the struct can be found <a href="https://github.com/EpicGames/UnrealEngine/blob/d9d435c9c280b99a6c679b517adedd3f4b02cfd7/Engine/Source/Runtime/Engine/Classes/Engine/Engine.h#L266">here</a>.</p>

<p>Now say for example, after we traveled to <code class="language-plaintext highlighter-rouge">MyMap</code>, we traveled to <code class="language-plaintext highlighter-rouge">MyOtherMap</code> this way:</p>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/open-level-relative.png" alt="OpenLevelRelative" class="align-center"></p>

<p>Notice that this time <code class="language-plaintext highlighter-rouge">bAbsolute = false</code>, meaning that the travel is of type <code class="language-plaintext highlighter-rouge">TRAVEL_Relative</code>. As mentioned earlier, this means that the last <strong>URL</strong> is kept (we are still on the same server), and last options string is kept too, which gets prepended to current options string we are traveling with. So the new options string will look like this: <code class="language-plaintext highlighter-rouge">?MaxPlayers=3?Listen?Name=MyAwesomeName</code>.</p>

<p>You might have noticed that that there is a missing <code class="language-plaintext highlighter-rouge">?Listen</code> at the start of the string. The reason being, the engine is preventing us from shooting ourself in the foot, so it removes it:</p>

<figure>
      <figcaption>
        <p class="figure-title">UnrealEngine.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code><span class="kt">void</span> <span class="n">UEngine</span><span class="o">::</span><span class="n">SetClientTravel</span><span class="p">(</span> <span class="n">UWorld</span> <span class="o">*</span><span class="n">InWorld</span><span class="p">,</span> <span class="k">const</span> <span class="n">TCHAR</span><span class="o">*</span> <span class="n">NextURL</span><span class="p">,</span> <span class="n">ETravelType</span> <span class="n">InTravelType</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">FWorldContext</span> <span class="o">&amp;</span><span class="n">Context</span> <span class="o">=</span> <span class="n">GetWorldContextFromWorldChecked</span><span class="p">(</span><span class="n">InWorld</span><span class="p">);</span>

    <span class="c1">// set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().</span>
    <span class="n">Context</span><span class="p">.</span><span class="n">TravelURL</span>    <span class="o">=</span> <span class="n">NextURL</span><span class="p">;</span>
    <span class="n">Context</span><span class="p">.</span><span class="n">TravelType</span>   <span class="o">=</span> <span class="n">InTravelType</span><span class="p">;</span>

    <span class="c1">// Prevent crashing the game by attempting to connect to own listen server</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Context</span><span class="p">.</span><span class="n">LastURL</span><span class="p">.</span><span class="n">HasOption</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Listen"</span><span class="p">))</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Context</span><span class="p">.</span><span class="n">LastURL</span><span class="p">.</span><span class="n">RemoveOption</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Listen"</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


  </div></figure>

<p>This function is called for all types of travels (including disconnects, which in fact are travels too), for any client that travels (including client that loads as a host).</p>

<h3 id="usage-6">Usage<a class="header-link" href="#usage-6" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>Persist primitive data types upon traveling (regardless of the travel type).</li>
  <li>Pass data to the server when loading for the first time (<strong>hard</strong> travel).</li>
  <li>Rapid testing.</li>
</ul>

<h3 id="example-usage-6" class="">Example Usage<a class="header-link" href="#example-usage-6" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<ul>
  <li>The following are examples of launching standalone via the command line:</li>
</ul>

<figure>
      <figcaption>
        <p class="figure-title">UnrealEngine.cpp</p>
      </figcaption>
    <div class="figcontent">
    
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><button title="Copy to clipboard" class="clipboard-copy-button"><span class="sr-only">Copy code</span><i class="far fa-fw fa-copy"></i><i class="fas fa-fw fa-check copied"></i></button><code>MyGame.exe /Game/Maps/MyMap
UnrealEditor.exe MyGame.uproject /Game/Maps/MyMap?game<span class="o">=</span>MyGameMode <span class="nt">-game</span>
UnrealEditor.exe MyGame.uproject /Game/Maps/MyMap?listen <span class="nt">-server</span>
MyGame.exe 127.0.0.1
</code></pre></div></div>


  </div></figure>

<ul>
  <li>The following is an example of a player hosting a map (by pressing 1), and another player joining him (by pressing 2):</li>
</ul>

<p><img src="https://wizardcell.com//assets/blog/persistent-data/host-and-join.png" alt="HostAndJoin" class="align-center"></p>

<h2 id="8-database" class="">8. Database<a class="header-link" href="#8-database" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Coming Soon<img class="emoji" title=":tm:" alt=":tm:" src="https://github.githubassets.com/images/icons/emoji/unicode/2122.png" height="20" width="20"></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#c" class="page__taxonomy-item p-category" rel="tag">C++</a><span class="sep">, </span>
    
      <a href="/tags/#data" class="page__taxonomy-item p-category" rel="tag">Data</a>
    
    </span>
  </p>




        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Posted:</strong> <time class="dt-published" datetime="2023-04-23">September 1, 2022</time></p>


  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2022-09-01T00:00:00+00:00">April 23, 2023</time></p>

      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=WizardCells&amp;text=Unreal+Engine+Persistent+Data+Compendium%20https%3A%2F%2Fwizardcell.com%2Funreal%2Fpersistent-data%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwizardcell.com%2Funreal%2Fpersistent-data%2F" class="btn btn--facebook fbc-has-badge fbc-UID_1" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fwizardcell.com%2Funreal%2Fpersistent-data%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/unreal/spectating-system/" class="pagination--pager" title="Spectating System in Unreal Engine
">Previous</a>
    
    
      <a href="/unreal/multiplayer-tips-and-tricks/" class="pagination--pager" title="Unreal Engine Multiplayer Tips and Tricks
">Next</a>
    
  </nav>

    </div>

    
  </article>